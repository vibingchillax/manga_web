generator client {
  provider = "prisma-client"
  output   = "../shared/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model ScrapedManga {
  id                     String                  @id @db.Uuid
  mangaDexId             String                  @db.Uuid
  sourceId               String
  title                  String
  url                    String                  @unique
  altTitles              Json?
  description            String?
  coverUrl               String?
  author                 String[]
  artist                 String[]
  publicationDemographic PublicationDemographic?
  status                 MangaStatus?
  year                   Int?
  contentRating          ContentRating?
  tags                   String[]
  originalLanguage       String?
  vote                   Int                     @default(0)
  version                Int                     @default(1)
  createdAt              DateTime                @default(now()) @db.Timestamp(6)
  updatedAt              DateTime                @default(now()) @updatedAt @db.Timestamp(6)
  chapters               ScrapedChapter[]
}

model ScrapedChapter {
  id                 String         @id @db.Uuid
  mangaId            String         @db.Uuid
  sourceId           String
  url                String         @unique
  title              String?
  volume             String?
  chapter            String?
  translatedLanguage String?
  uploader           String?
  scanlationGroup    String?
  branch             String?
  publishedAt        String?
  createdAt          DateTime       @default(now()) @db.Timestamp(6)
  updatedAt          DateTime       @default(now()) @updatedAt @db.Timestamp(6)
  manga              ScrapedManga   @relation(fields: [mangaId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  pages              ScrapedPage[]
}

model ScrapedPage {
  id              String          @id @db.Uuid
  chapterId       String          @db.Uuid
  data            String[]
  createdAt       DateTime        @default(now()) @db.Timestamp(6)
  updatedAt       DateTime        @default(now()) @updatedAt @db.Timestamp(6)
  chapter         ScrapedChapter  @relation(fields: [chapterId], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model User {
  id                    String                  @id @db.Uuid
  email                 String                  @unique
  password              String
  username              String                  @unique
  roles                 UserRole[]              @default([user])
  createdAt             DateTime                @default(now()) @db.Timestamp(6)
  updatedAt             DateTime                @default(now()) @updatedAt @db.Timestamp(6)
  MangaFollows          MangaFollows[]
  uploadedChapters      UploadedChapter[]
  uploadSession         UploadSession?
  RefreshToken          RefreshToken[]
  ScanlationGroupMember ScanlationGroupMember[]
}

model RefreshToken {
  id        String   @id @db.Uuid
  token     String   @unique
  userId    String   @db.Uuid
  expiresAt DateTime
  createdAt DateTime @default(now()) @db.Timestamp(6)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ScanlationGroup {
  id                    String                  @id @db.Uuid
  name                  String
  altNames              Json?
  website               String?
  ircServer             String?
  ircChannel            String?
  discord               String?
  contactEmail          String?
  description           String?
  twitter               String?
  mangaUpdates          String?
  inactive              Boolean                 @default(false)
  publishDelay          String                  @default("P0D")
  focusedLanguages      String[]
  locked                Boolean                 @default(false)
  official              Boolean                 @default(false) 
  verified              Boolean                 @default(false)
  exLicensed            Boolean                 @default(false)
  version               Int                     @default(1)
  createdAt             DateTime                @default(now()) @db.Timestamp(6)
  updatedAt             DateTime                @default(now()) @updatedAt @db.Timestamp(6)
  members               ScanlationGroupMember[]
  uploadSessions        UploadSessionGroup[]
  uploadedChapters      UploadedChapterGroup[]
}

model ScanlationGroupMember {
  userId  String          @db.Uuid
  groupId String          @db.Uuid
  role    GroupRole
  user    User            @relation(fields: [userId], references: [id])
  group   ScanlationGroup @relation(fields: [groupId], references: [id])

  @@id([userId, groupId])
}

model MangaFollows {
  userId  String            @db.Uuid
  mangaId String            @db.Uuid
  status  MangaFollowStatus
  user    User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, mangaId])
}

model UploadSession {
  id                String               @id @db.Uuid
  userId            String               @unique @db.Uuid
  mangaId           String               @db.Uuid
  data              Json?
  isCommitted       Boolean              @default(false)
  isProcessed       Boolean              @default(false)
  isDeleted         Boolean              @default(false)
  version           Int                  @default(1)
  createdAt         DateTime             @default(now()) @db.Timestamp(6)
  updatedAt         DateTime             @default(now()) @updatedAt @db.Timestamp(6)
  user              User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  groups            UploadSessionGroup[]
  UploadSessionFile UploadSessionFile[]
}

model UploadSessionFile {
  id               String        @id @db.Uuid
  sessionId        String        @db.Uuid
  originalFileName String
  cid              String
  fileSize         Int
  mimeType         String
  source           String
  version          Int           @default(1)
  session          UploadSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
}

model UploadSessionGroup {
  sessionId String          @db.Uuid
  groupId   String          @db.Uuid
  session   UploadSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  group     ScanlationGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@id([sessionId, groupId])
}

model UploadedChapter {
  id                 String                 @id @db.Uuid
  mangaId            String                 @db.Uuid
  title              String?
  volume             String?
  chapter            String?
  translatedLanguage String
  uploader           String                 @db.Uuid
  pages              Json
  version            Int                    @default(1)
  createdAt          DateTime               @default(now()) @db.Timestamp(6)
  updatedAt          DateTime               @default(now()) @updatedAt @db.Timestamp(6)
  publishAt          DateTime               @default(now())
  readableAt         DateTime               @default(now())
  user               User                   @relation(fields: [uploader], references: [id])
  groups             UploadedChapterGroup[]
}

model UploadedChapterGroup {
  chapterId String @db.Uuid
  groupId   String @db.Uuid

  chapter UploadedChapter @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  group   ScanlationGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@id([chapterId, groupId])
}

enum UserRole {
  banned
  user
  groupLeader
  admin
}

enum PublicationDemographic {
  shounen
  shoujo
  josei
  seinen
}

enum MangaStatus {
  completed
  ongoing
  cancelled
  hiatus
}

enum ContentRating {
  safe
  suggestive
  erotica
  pornographic
}

enum MangaFollowStatus {
  reading
  onHold
  dropped
  planToRead
  completed
  rereading
}

enum GroupRole {
  leader
  member
}
