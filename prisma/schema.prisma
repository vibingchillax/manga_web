generator client {
  provider = "prisma-client"
  output   = "../shared/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model scrapedMangas {
  id                     String                  @id @db.Uuid
  mangaDexId             String                  @db.Uuid
  sourceId               String
  title                  String
  url                    String                  @unique
  altTitles              Json?
  description            String?
  coverUrl               String?
  author                 String[]
  artist                 String[]
  publicationDemographic PublicationDemographic?
  status                 MangaStatus?
  year                   Int?
  contentRating          ContentRating?
  tags                   String[]
  originalLanguage       String?
  vote                   Int                     @default(0)
  version                Int                     @default(1)
  createdAt              DateTime                @default(now()) @db.Timestamp(6)
  updatedAt              DateTime                @default(now()) @updatedAt @db.Timestamp(6)
  scrapedChapters        scrapedChapters[]
}

model scrapedChapters {
  id                 String         @id @db.Uuid
  mangaId            String         @db.Uuid
  sourceId           String
  url                String         @unique
  title              String?
  volume             String?
  chapter            String?
  translatedLanguage String?
  uploader           String?
  scanlationGroup    String?
  branch             String?
  publishedAt        String?
  createdAt          DateTime       @default(now()) @db.Timestamp(6)
  updatedAt          DateTime       @default(now()) @updatedAt @db.Timestamp(6)
  scrapedMangas      scrapedMangas  @relation(fields: [mangaId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  scrapedPages       scrapedPages[]
}

model scrapedPages {
  id              String          @id @db.Uuid
  chapterId       String          @db.Uuid
  data            String[]
  createdAt       DateTime        @default(now()) @db.Timestamp(6)
  updatedAt       DateTime        @default(now()) @updatedAt @db.Timestamp(6)
  scrapedChapters scrapedChapters @relation(fields: [chapterId], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model Users {
  id                    String                  @id @db.Uuid
  email                 String                  @unique
  password              String
  username              String?
  role                  UserRole                @default(user)
  createdAt             DateTime                @default(now()) @db.Timestamp(6)
  updatedAt             DateTime                @default(now()) @updatedAt @db.Timestamp(6)
  MangaFollows          MangaFollows[]
  uploadedChapters      UploadedChapter[]
  uploadSession         UploadSession?
  ScanlationGroupMember ScanlationGroupMember[]
}

model ScanlationGroup {
  id                    String                  @id @db.Uuid
  name                  String
  altNames              Json?
  website               String?
  ircServer             String?
  ircChannel            String?
  discord               String?
  contactEmail          String?
  description           String?
  twitter               String?
  mangaUpdates          String?
  focusedLanguage       String[]
  locked                Boolean
  official              Boolean
  verified              Boolean
  inactive              Boolean
  exLicensed            Boolean
  version               Int                     @default(1)
  createdAt             DateTime                @default(now()) @db.Timestamp(6)
  updatedAt             DateTime                @default(now()) @updatedAt @db.Timestamp(6)
  ScanlationGroupMember ScanlationGroupMember[]
  UploadSessionGroup    UploadSessionGroup[]
  UploadedChapterGroup  UploadedChapterGroup[]
}

model ScanlationGroupMember {
  userId  String          @db.Uuid
  groupId String          @db.Uuid
  role    GroupRole
  user    Users           @relation(fields: [userId], references: [id])
  group   ScanlationGroup @relation(fields: [groupId], references: [id])

  @@id([userId, groupId])
}

model MangaFollows {
  userId  String            @db.Uuid
  mangaId String            @db.Uuid
  status  MangaFollowStatus
  user    Users             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, mangaId])
}

model UploadSession {
  id                String               @id @db.Uuid
  userId            String               @unique @db.Uuid
  mangaId           String               @db.Uuid
  data              Json?
  isCommitted       Boolean              @default(false)
  isProcessed       Boolean              @default(false)
  isDeleted         Boolean              @default(false)
  version           Int                  @default(1)
  createdAt         DateTime             @default(now()) @db.Timestamp(6)
  updatedAt         DateTime             @default(now()) @updatedAt @db.Timestamp(6)
  user              Users                @relation(fields: [userId], references: [id], onDelete: Cascade)
  groups            UploadSessionGroup[]
  UploadSessionFile UploadSessionFile[]
}

model UploadSessionFile {
  id               String        @id @db.Uuid
  sessionId        String        @db.Uuid
  originalFileName String
  cid              String
  fileSize         Int
  mimeType         String
  source           String
  version          Int           @default(1)
  session          UploadSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
}

model UploadSessionGroup {
  sessionId String          @db.Uuid
  groupId   String          @db.Uuid
  session   UploadSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  group     ScanlationGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@id([sessionId, groupId])
}

model UploadedChapter {
  id                 String                 @id @db.Uuid
  mangaId            String                 @db.Uuid
  title              String?
  volume             String?
  chapter            String?
  translatedLanguage String
  uploader           String                 @db.Uuid
  pages              Json
  version            Int                    @default(1)
  createdAt          DateTime               @default(now()) @db.Timestamp(6)
  updatedAt          DateTime               @default(now()) @updatedAt @db.Timestamp(6)
  publishAt          DateTime               @default(now())
  readableAt         DateTime               @default(now())
  user               Users                  @relation(fields: [uploader], references: [id])
  groups             UploadedChapterGroup[]
}

model UploadedChapterGroup {
  chapterId String @db.Uuid
  groupId   String @db.Uuid

  chapter UploadedChapter @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  group   ScanlationGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@id([chapterId, groupId])
}

enum UserRole {
  user
  admin
}

enum PublicationDemographic {
  shounen
  shoujo
  josei
  seinen
}

enum MangaStatus {
  completed
  ongoing
  cancelled
  hiatus
}

enum ContentRating {
  safe
  suggestive
  erotica
  pornographic
}

enum MangaFollowStatus {
  reading
  onHold
  dropped
  planToRead
  completed
  rereading
}

enum GroupRole {
  leader
  member
}
