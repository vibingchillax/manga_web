/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * MangaDex API
 * MangaDex is an ad-free manga reader offering high-quality images!

This document details our API as it is right now. It is in no way a promise to never change it, although we will endeavour to publicly notify any major change.

# Acceptable use policy

Usage of our services implies acceptance of the following:
- You **MUST** credit us
- You **MUST** credit scanlation groups if you offer the ability to read chapters
- You **CANNOT** run ads or paid services on your website and/or apps

These may change at any time for any and no reason and it is up to you check for updates from time to time.

# Security issues

If you believe you found a security issue in our API, please check our [security.txt](/security.txt) to get in touch privately.

 * OpenAPI spec version: 5.12.0
 */
import { axiosFetch } from '../utils/axiosInstance';
export type MangaRequestLinks = {[key: string]: string};

/**
 * @nullable
 */
export type MangaRequestPublicationDemographic = typeof MangaRequestPublicationDemographic[keyof typeof MangaRequestPublicationDemographic] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MangaRequestPublicationDemographic = {
  shounen: 'shounen',
  shoujo: 'shoujo',
  josei: 'josei',
  seinen: 'seinen',
} as const;

/**
 */
export type MangaRequestStatus = typeof MangaRequestStatus[keyof typeof MangaRequestStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MangaRequestStatus = {
  completed: 'completed',
  ongoing: 'ongoing',
  cancelled: 'cancelled',
  hiatus: 'hiatus',
} as const;

export type MangaRequestContentRating = typeof MangaRequestContentRating[keyof typeof MangaRequestContentRating];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MangaRequestContentRating = {
  safe: 'safe',
  suggestive: 'suggestive',
  erotica: 'erotica',
  pornographic: 'pornographic',
} as const;

export interface MangaRequest {
  title?: LocalizedString;
  altTitles?: LocalizedString[];
  description?: LocalizedString;
  authors?: string[];
  artists?: string[];
  links?: MangaRequestLinks;
  /** @pattern ^[a-z]{2}(-[a-z]{2})?$ */
  originalLanguage?: string;
  /** @nullable */
  lastVolume?: string | null;
  /** @nullable */
  lastChapter?: string | null;
  /** @nullable */
  publicationDemographic?: MangaRequestPublicationDemographic;
  /** */
  status?: MangaRequestStatus;
  /**
   * Year of release
   * @minimum 1
   * @maximum 9999
   * @nullable
   */
  year?: number | null;
  contentRating?: MangaRequestContentRating;
  chapterNumbersResetOnNewVolume?: boolean;
  tags?: string[];
  /** @nullable */
  primaryCover?: string | null;
  /** @minimum 1 */
  version?: number;
}

export interface LocalizedString {[key: string]: string}

export type MangaResponseResult = typeof MangaResponseResult[keyof typeof MangaResponseResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MangaResponseResult = {
  ok: 'ok',
  error: 'error',
} as const;

export interface MangaResponse {
  result?: MangaResponseResult;
  response?: string;
  data?: Manga;
}

export type ChapterResponseResult = typeof ChapterResponseResult[keyof typeof ChapterResponseResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ChapterResponseResult = {
  ok: 'ok',
  error: 'error',
} as const;

export interface ChapterResponse {
  result?: ChapterResponseResult;
  response?: string;
  data?: Chapter;
}

/**
 * Related Manga type, only present if you are on a Manga entity and a Manga relationship
 */
export type RelationshipRelated = typeof RelationshipRelated[keyof typeof RelationshipRelated];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RelationshipRelated = {
  monochrome: 'monochrome',
  main_story: 'main_story',
  adapted_from: 'adapted_from',
  based_on: 'based_on',
  prequel: 'prequel',
  side_story: 'side_story',
  doujinshi: 'doujinshi',
  same_franchise: 'same_franchise',
  shared_universe: 'shared_universe',
  sequel: 'sequel',
  spin_off: 'spin_off',
  alternate_story: 'alternate_story',
  alternate_version: 'alternate_version',
  preserialization: 'preserialization',
  colored: 'colored',
  serialization: 'serialization',
} as const;

/**
 * If Reference Expansion is applied, contains objects attributes
 * @nullable
 */
export type RelationshipAttributes = { [key: string]: unknown } | null;

export interface Relationship {
  id?: string;
  type?: string;
  /** Related Manga type, only present if you are on a Manga entity and a Manga relationship */
  related?: RelationshipRelated;
  /**
   * If Reference Expansion is applied, contains objects attributes
   * @nullable
   */
  attributes?: RelationshipAttributes;
}

export type ChapterType = typeof ChapterType[keyof typeof ChapterType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ChapterType = {
  chapter: 'chapter',
} as const;

export interface Chapter {
  id?: string;
  type?: ChapterType;
  attributes?: ChapterAttributes;
  relationships?: Relationship[];
}

export type MangaType = typeof MangaType[keyof typeof MangaType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MangaType = {
  manga: 'manga',
} as const;

export interface Manga {
  id?: string;
  type?: MangaType;
  attributes?: MangaAttributes;
  relationships?: Relationship[];
}

export interface ErrorResponse {
  result?: string;
  errors?: Error[];
}

export interface Error {
  id?: string;
  status?: number;
  title?: string;
  /** @nullable */
  detail?: string | null;
  /** @nullable */
  context?: string | null;
}

export interface ChapterAttributes {
  /**
   * @maxLength 255
   * @nullable
   */
  title?: string | null;
  /** @nullable */
  volume?: string | null;
  /**
   * @maxLength 8
   * @nullable
   */
  chapter?: string | null;
  /** Count of readable images for this chapter */
  pages?: number;
  /** @pattern ^[a-z]{2}(-[a-z]{2})?$ */
  translatedLanguage?: string;
  uploader?: string;
  /**
   * Denotes a chapter that links to an external source.
   * @maxLength 512
   * @nullable
   * @pattern ^https?://
   */
  externalUrl?: string | null;
  /** @minimum 1 */
  version?: number;
  createdAt?: string;
  updatedAt?: string;
  publishAt?: string;
  readableAt?: string;
  isUnavailable?: boolean;
}

export type MangaAttributesLinks = {[key: string]: string};

/**
 * @nullable
 */
export type MangaAttributesPublicationDemographic = typeof MangaAttributesPublicationDemographic[keyof typeof MangaAttributesPublicationDemographic] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MangaAttributesPublicationDemographic = {
  shounen: 'shounen',
  shoujo: 'shoujo',
  josei: 'josei',
  seinen: 'seinen',
} as const;

/**
 */
export type MangaAttributesStatus = typeof MangaAttributesStatus[keyof typeof MangaAttributesStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MangaAttributesStatus = {
  completed: 'completed',
  ongoing: 'ongoing',
  cancelled: 'cancelled',
  hiatus: 'hiatus',
} as const;

export type MangaAttributesContentRating = typeof MangaAttributesContentRating[keyof typeof MangaAttributesContentRating];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MangaAttributesContentRating = {
  safe: 'safe',
  suggestive: 'suggestive',
  erotica: 'erotica',
  pornographic: 'pornographic',
} as const;

export type MangaAttributesState = typeof MangaAttributesState[keyof typeof MangaAttributesState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MangaAttributesState = {
  draft: 'draft',
  submitted: 'submitted',
  published: 'published',
  rejected: 'rejected',
} as const;

export interface MangaAttributes {
  title?: LocalizedString;
  altTitles?: LocalizedString[];
  description?: LocalizedString;
  isLocked?: boolean;
  links?: MangaAttributesLinks;
  originalLanguage?: string;
  /** @nullable */
  lastVolume?: string | null;
  /** @nullable */
  lastChapter?: string | null;
  /** @nullable */
  publicationDemographic?: MangaAttributesPublicationDemographic;
  /** */
  status?: MangaAttributesStatus;
  /**
   * Year of release
   * @nullable
   */
  year?: number | null;
  contentRating?: MangaAttributesContentRating;
  chapterNumbersResetOnNewVolume?: boolean;
  availableTranslatedLanguages?: string[];
  latestUploadedChapter?: string;
  tags?: Tag[];
  state?: MangaAttributesState;
  /** @minimum 1 */
  version?: number;
  createdAt?: string;
  updatedAt?: string;
}

export type MangaCreate = MangaRequest & unknown;

export type MangaEdit = MangaRequest & unknown;

export type ChapterEdit = ChapterRequest & unknown;

export type ResponseResult = typeof ResponseResult[keyof typeof ResponseResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseResult = {
  ok: 'ok',
  error: 'error',
} as const;

export interface Response {
  result?: ResponseResult;
}

export interface Login {
  /**
   * @minLength 1
   * @maxLength 64
   */
  username?: string;
  email?: string;
  /**
   * @minLength 8
   * @maxLength 1024
   */
  password: string;
}

export type LoginResponseResult = typeof LoginResponseResult[keyof typeof LoginResponseResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LoginResponseResult = {
  ok: 'ok',
  error: 'error',
} as const;

export type LoginResponseToken = {
  session?: string;
  refresh?: string;
};

export interface LoginResponse {
  result?: LoginResponseResult;
  token?: LoginResponseToken;
}

export interface CheckResponse {
  result?: string;
  isAuthenticated?: boolean;
  roles?: string[];
  permissions?: string[];
}

export type LogoutResponseResult = typeof LogoutResponseResult[keyof typeof LogoutResponseResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LogoutResponseResult = {
  ok: 'ok',
  error: 'error',
} as const;

export interface LogoutResponse {
  result?: LogoutResponseResult;
}

export interface RefreshToken {
  /** @minLength 1 */
  token: string;
}

export type RefreshResponseResult = typeof RefreshResponseResult[keyof typeof RefreshResponseResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RefreshResponseResult = {
  ok: 'ok',
  error: 'error',
} as const;

export type RefreshResponseToken = {
  session?: string;
  refresh?: string;
};

export interface RefreshResponse {
  result: RefreshResponseResult;
  token?: RefreshResponseToken;
  message?: string;
}

export type AccountActivateResponseResult = typeof AccountActivateResponseResult[keyof typeof AccountActivateResponseResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountActivateResponseResult = {
  ok: 'ok',
} as const;

export interface AccountActivateResponse {
  result?: AccountActivateResponseResult;
}

export interface CreateAccount {
  /**
   * @minLength 1
   * @maxLength 64
   */
  username: string;
  /**
   * @minLength 8
   * @maxLength 1024
   */
  password: string;
  email: string;
}

export type ScanlationGroupResponseResult = typeof ScanlationGroupResponseResult[keyof typeof ScanlationGroupResponseResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ScanlationGroupResponseResult = {
  ok: 'ok',
} as const;

export interface ScanlationGroupResponse {
  result?: ScanlationGroupResponseResult;
  response?: string;
  data?: ScanlationGroup;
}

export type ScanlationGroupType = typeof ScanlationGroupType[keyof typeof ScanlationGroupType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ScanlationGroupType = {
  scanlation_group: 'scanlation_group',
} as const;

export interface ScanlationGroup {
  id?: string;
  type?: ScanlationGroupType;
  attributes?: ScanlationGroupAttributes;
  relationships?: Relationship[];
}

export interface ScanlationGroupAttributes {
  name?: string;
  altNames?: LocalizedString[];
  /** @nullable */
  website?: string | null;
  /** @nullable */
  ircServer?: string | null;
  /** @nullable */
  ircChannel?: string | null;
  /** @nullable */
  discord?: string | null;
  /** @nullable */
  contactEmail?: string | null;
  /** @nullable */
  description?: string | null;
  /**
   * @nullable
   * @pattern ^https?://
   */
  twitter?: string | null;
  /**
   * @maxLength 128
   * @nullable
   * @pattern ^https:\/\/www\.mangaupdates\.com\/(group|publisher)(s\.html\?id=\d+|\/[\w-]+\/?([\w-]+)?(\/)?)$
   */
  mangaUpdates?: string | null;
  /** @nullable */
  focusedLanguage?: string[] | null;
  locked?: boolean;
  official?: boolean;
  verified?: boolean;
  inactive?: boolean;
  exLicensed?: boolean;
  /**
   * Should respected ISO 8601 duration specification: https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @pattern ^(P([1-9]|[1-9][0-9])D)?(P?([1-9])W)?(P?T(([1-9]|1[0-9]|2[0-4])H)?(([1-9]|[1-5][0-9]|60)M)?(([1-9]|[1-5][0-9]|60)S)?)?$
   */
  publishDelay?: string;
  /** @minimum 1 */
  version?: number;
  createdAt?: string;
  updatedAt?: string;
}

export type UserType = typeof UserType[keyof typeof UserType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserType = {
  user: 'user',
} as const;

export interface User {
  id?: string;
  type?: UserType;
  attributes?: UserAttributes;
  relationships?: Relationship[];
}

export interface UserAttributes {
  username?: string;
  roles?: string[];
  /** @minimum 1 */
  version?: number;
}

export interface CreateScanlationGroup {
  name: string;
  /** @nullable */
  website?: string | null;
  /** @nullable */
  ircServer?: string | null;
  /** @nullable */
  ircChannel?: string | null;
  /** @nullable */
  discord?: string | null;
  /** @nullable */
  contactEmail?: string | null;
  /** @nullable */
  description?: string | null;
  /**
   * @nullable
   * @pattern ^https?://twitter\.com
   */
  twitter?: string | null;
  /**
   * @maxLength 128
   * @nullable
   * @pattern ^https:\/\/www\.mangaupdates\.com\/(group|publisher)(s\.html\?id=\d+|\/[\w-]+\/?([\w-]+)?(\/)?)$
   */
  mangaUpdates?: string | null;
  inactive?: boolean;
  /**
   * @nullable
   * @pattern ^P(([1-9]|[1-9][0-9])D)?(([1-9])W)?(T(([1-9]|1[0-9]|2[0-4])H)?(([1-9]|[1-5][0-9]|60)M)?(([1-9]|[1-5][0-9]|60)S)?)?$
   */
  publishDelay?: string | null;
}

export interface ScanlationGroupEdit {
  name?: string;
  leader?: string;
  members?: string[];
  /** @nullable */
  website?: string | null;
  /** @nullable */
  ircServer?: string | null;
  /** @nullable */
  ircChannel?: string | null;
  /** @nullable */
  discord?: string | null;
  /** @nullable */
  contactEmail?: string | null;
  /** @nullable */
  description?: string | null;
  /**
   * @nullable
   * @pattern ^https?://
   */
  twitter?: string | null;
  /**
   * @maxLength 128
   * @nullable
   * @pattern ^https:\/\/www\.mangaupdates\.com\/(group|publisher)(s\.html\?id=\d+|\/[\w-]+\/?([\w-]+)?(\/)?)$
   */
  mangaUpdates?: string | null;
  /** @nullable */
  focusedLanguages?: string[] | null;
  inactive?: boolean;
  locked?: boolean;
  publishDelay?: string;
  /** @minimum 1 */
  version: number;
}

export type CustomListCreateVisibility = typeof CustomListCreateVisibility[keyof typeof CustomListCreateVisibility];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CustomListCreateVisibility = {
  public: 'public',
  private: 'private',
} as const;

export interface CustomListCreate {
  name: string;
  visibility?: CustomListCreateVisibility;
  manga?: string[];
  /** @minimum 1 */
  version?: number;
}

export type CustomListEditVisibility = typeof CustomListEditVisibility[keyof typeof CustomListEditVisibility];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CustomListEditVisibility = {
  public: 'public',
  private: 'private',
} as const;

export interface CustomListEdit {
  name?: string;
  visibility?: CustomListEditVisibility;
  manga?: string[];
  /** @minimum 1 */
  version: number;
}

export type CustomListResponseResult = typeof CustomListResponseResult[keyof typeof CustomListResponseResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CustomListResponseResult = {
  ok: 'ok',
  error: 'error',
} as const;

export interface CustomListResponse {
  result?: CustomListResponseResult;
  response?: string;
  data?: CustomList;
}

export type CustomListType = typeof CustomListType[keyof typeof CustomListType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CustomListType = {
  custom_list: 'custom_list',
} as const;

export interface CustomList {
  id?: string;
  type?: CustomListType;
  attributes?: CustomListAttributes;
  relationships?: Relationship[];
}

export type CustomListAttributesVisibility = typeof CustomListAttributesVisibility[keyof typeof CustomListAttributesVisibility];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CustomListAttributesVisibility = {
  private: 'private',
  public: 'public',
} as const;

export interface CustomListAttributes {
  name?: string;
  visibility?: CustomListAttributesVisibility;
  /** @minimum 1 */
  version?: number;
}

export interface CoverResponse {
  result?: string;
  response?: string;
  data?: Cover;
}

export type CoverType = typeof CoverType[keyof typeof CoverType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CoverType = {
  cover_art: 'cover_art',
} as const;

export interface Cover {
  id?: string;
  type?: CoverType;
  attributes?: CoverAttributes;
  relationships?: Relationship[];
}

export interface CoverAttributes {
  /** @nullable */
  volume?: string | null;
  fileName?: string;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  locale?: string | null;
  /** @minimum 1 */
  version?: number;
  createdAt?: string;
  updatedAt?: string;
}

export interface CoverEdit {
  volume: CoverVolume;
  /**
   * @minLength 0
   * @maxLength 512
   * @nullable
   */
  description?: string | null;
  /**
   * @nullable
   * @pattern ^[a-z]{2}(-[a-z]{2})?$
   */
  locale?: string | null;
  /** @minimum 1 */
  version: number;
}

/**
 * @maxLength 8
 * @nullable
 * @pattern ^(0|[1-9]\d*)(\.\d+)?([a-z]+)?$
 */
export type CoverVolume = string | null;

/**
 * @maxLength 8
 * @nullable
 * @pattern ^((0|[1-9]\d*)(\.\d+)?[a-z]?)?$
 */
export type ChapterVolume = string | null;

export interface AuthorResponse {
  result?: string;
  response?: string;
  data?: Author;
}

export type AuthorType = typeof AuthorType[keyof typeof AuthorType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthorType = {
  author: 'author',
} as const;

export interface Author {
  id?: string;
  type?: AuthorType;
  attributes?: AuthorAttributes;
  relationships?: Relationship[];
}

export interface AuthorAttributes {
  name?: string;
  /** @nullable */
  imageUrl?: string | null;
  biography?: LocalizedString;
  /**
   * @nullable
   * @pattern ^https?://twitter\.com(/|$)
   */
  twitter?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?pixiv\.net(/|$)
   */
  pixiv?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?melonbooks\.co\.jp(/|$)
   */
  melonBook?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?fanbox\.cc(/|$)
   */
  fanBox?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?booth\.pm(/|$)
   */
  booth?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?nicovideo\.jp(/|$)
   */
  nicoVideo?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?skeb\.jp(/|$)
   */
  skeb?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?fantia\.jp(/|$)
   */
  fantia?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?tumblr\.com(/|$)
   */
  tumblr?: string | null;
  /**
   * @nullable
   * @pattern ^https?://www\.youtube\.com(/|$)
   */
  youtube?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?weibo\.(cn|com)(/|$)
   */
  weibo?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?naver\.com(/|$)
   */
  naver?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?namicomi\.com(/|$)
   */
  namicomi?: string | null;
  /**
   * @nullable
   * @pattern ^https?://
   */
  website?: string | null;
  /** @minimum 1 */
  version?: number;
  createdAt?: string;
  updatedAt?: string;
}

export interface AuthorEdit {
  name?: string;
  biography?: LocalizedString;
  /**
   * @nullable
   * @pattern ^https?://twitter\.com(/|$)
   */
  twitter?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?pixiv\.net(/|$)
   */
  pixiv?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?melonbooks\.co\.jp(/|$)
   */
  melonBook?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?fanbox\.cc(/|$)
   */
  fanBox?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?booth\.pm(/|$)
   */
  booth?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?nicovideo\.jp(/|$)
   */
  nicoVideo?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?skeb\.jp(/|$)
   */
  skeb?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?fantia\.jp(/|$)
   */
  fantia?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?tumblr\.com(/|$)
   */
  tumblr?: string | null;
  /**
   * @nullable
   * @pattern ^https?://www\.youtube\.com(/|$)
   */
  youtube?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?weibo\.(cn|com)(/|$)
   */
  weibo?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?naver\.com(/|$)
   */
  naver?: string | null;
  /**
   * @nullable
   * @pattern ^https?://
   */
  website?: string | null;
  /** @minimum 1 */
  version: number;
}

export interface AuthorCreate {
  name: string;
  biography?: LocalizedString;
  /**
   * @nullable
   * @pattern ^https?://twitter\.com(/|$)
   */
  twitter?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?pixiv\.net(/|$)
   */
  pixiv?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?melonbooks\.co\.jp(/|$)
   */
  melonBook?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?fanbox\.cc(/|$)
   */
  fanBox?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?booth\.pm(/|$)
   */
  booth?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?nicovideo\.jp(/|$)
   */
  nicoVideo?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?skeb\.jp(/|$)
   */
  skeb?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?fantia\.jp(/|$)
   */
  fantia?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?tumblr\.com(/|$)
   */
  tumblr?: string | null;
  /**
   * @nullable
   * @pattern ^https?://www\.youtube\.com(/|$)
   */
  youtube?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?weibo\.(cn|com)(/|$)
   */
  weibo?: string | null;
  /**
   * @nullable
   * @pattern ^https?://([\w-]+\.)?naver\.com(/|$)
   */
  naver?: string | null;
  /**
   * @nullable
   * @pattern ^https?://
   */
  website?: string | null;
}

export interface ApiClientResponse {
  result?: string;
  response?: string;
  data?: ApiClient;
}

export type ApiClientType = typeof ApiClientType[keyof typeof ApiClientType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApiClientType = {
  api_client: 'api_client',
} as const;

export interface ApiClient {
  id?: string;
  type?: ApiClientType;
  attributes?: ApiClientAttributes;
  relationships?: Relationship[];
}

export type ApiClientAttributesState = typeof ApiClientAttributesState[keyof typeof ApiClientAttributesState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApiClientAttributesState = {
  requested: 'requested',
  approved: 'approved',
  rejected: 'rejected',
  autoapproved: 'autoapproved',
} as const;

export interface ApiClientAttributes {
  name?: string;
  /**
   * @maxLength 256
   * @nullable
   */
  description?: string | null;
  profile?: string;
  /** @nullable */
  externalClientId?: string | null;
  isActive?: boolean;
  state?: ApiClientAttributesState;
  createdAt?: string;
  updatedAt?: string;
  /** @minimum 1 */
  version?: number;
}

export interface ApiClientEdit {
  /** @nullable */
  description?: string | null;
  /** @minimum 1 */
  version: number;
}

export type ApiClientCreateProfile = typeof ApiClientCreateProfile[keyof typeof ApiClientCreateProfile];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApiClientCreateProfile = {
  personal: 'personal',
} as const;

export interface ApiClientCreate {
  /**
   * @minLength 5
   * @maxLength 32
   */
  name: string;
  /**
   * @maxLength 256
   * @nullable
   */
  description?: string | null;
  profile: ApiClientCreateProfile;
  /** @minimum 1 */
  version?: number;
}

export type MappingIdBodyType = typeof MappingIdBodyType[keyof typeof MappingIdBodyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MappingIdBodyType = {
  group: 'group',
  manga: 'manga',
  chapter: 'chapter',
  tag: 'tag',
} as const;

export interface MappingIdBody {
  type?: MappingIdBodyType;
  ids?: number[];
}

export interface MappingIdResponse {
  result?: string;
  response?: string;
  data?: MappingId[];
  limit?: number;
  offset?: number;
  total?: number;
}

export type MappingIdType = typeof MappingIdType[keyof typeof MappingIdType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MappingIdType = {
  mapping_id: 'mapping_id',
} as const;

export interface MappingId {
  id?: string;
  type?: MappingIdType;
  attributes?: MappingIdAttributes;
  relationships?: Relationship[];
}

export type MappingIdAttributesType = typeof MappingIdAttributesType[keyof typeof MappingIdAttributesType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MappingIdAttributesType = {
  manga: 'manga',
  chapter: 'chapter',
  group: 'group',
  tag: 'tag',
} as const;

export interface MappingIdAttributes {
  type?: MappingIdAttributesType;
  legacyId?: number;
  newId?: string;
}

export interface TagResponse {
  result?: string;
  response?: string;
  data?: Tag[];
  limit?: number;
  offset?: number;
  total?: number;
}

export type TagType = typeof TagType[keyof typeof TagType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TagType = {
  tag: 'tag',
} as const;

export interface Tag {
  id?: string;
  type?: TagType;
  attributes?: TagAttributes;
  relationships?: Relationship[];
}

export type TagAttributesGroup = typeof TagAttributesGroup[keyof typeof TagAttributesGroup];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TagAttributesGroup = {
  content: 'content',
  format: 'format',
  genre: 'genre',
  theme: 'theme',
} as const;

export interface TagAttributes {
  name?: LocalizedString;
  description?: LocalizedString;
  group?: TagAttributesGroup;
  /** @minimum 1 */
  version?: number;
}

export type UserResponseResult = typeof UserResponseResult[keyof typeof UserResponseResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserResponseResult = {
  ok: 'ok',
} as const;

export interface UserResponse {
  result?: UserResponseResult;
  response?: string;
  data?: User;
}

export interface SendAccountActivationCode {
  email: string;
}

export interface RecoverCompleteBody {
  /**
   * @minLength 8
   * @maxLength 1024
   */
  newPassword: string;
}

/**
 * @nullable
 */
export type UpdateMangaStatusStatus = typeof UpdateMangaStatusStatus[keyof typeof UpdateMangaStatusStatus] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateMangaStatusStatus = {
  reading: 'reading',
  on_hold: 'on_hold',
  plan_to_read: 'plan_to_read',
  dropped: 'dropped',
  re_reading: 're_reading',
  completed: 'completed',
} as const;

export interface UpdateMangaStatus {
  /** @nullable */
  status: UpdateMangaStatusStatus;
}

export interface ChapterRequest {
  /**
   * @maxLength 255
   * @nullable
   */
  title?: string | null;
  volume?: ChapterVolume;
  chapter?: ChapterVolume;
  /** @pattern ^[a-z]{2}(-[a-z]{2})?$ */
  translatedLanguage?: string;
  /** @maxItems 10 */
  groups?: string[];
  /** @minimum 1 */
  version?: number;
}

export interface CoverList {
  result?: string;
  response?: string;
  data?: Cover[];
  limit?: number;
  offset?: number;
  total?: number;
}

export interface AuthorList {
  result?: string;
  response?: string;
  data?: Author[];
  limit?: number;
  offset?: number;
  total?: number;
}

export interface ApiClientList {
  result?: string;
  response?: string;
  data?: ApiClient[];
  limit?: number;
  offset?: number;
  total?: number;
}

export interface ChapterList {
  result?: string;
  response?: string;
  data?: Chapter[];
  limit?: number;
  offset?: number;
  total?: number;
}

export interface ScanlationGroupList {
  result?: string;
  response?: string;
  data?: ScanlationGroup[];
  limit?: number;
  offset?: number;
  total?: number;
}

export type MangaRelationCreate = MangaRelationRequest & unknown;

export type MangaRelationRequestRelation = typeof MangaRelationRequestRelation[keyof typeof MangaRelationRequestRelation];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MangaRelationRequestRelation = {
  monochrome: 'monochrome',
  main_story: 'main_story',
  adapted_from: 'adapted_from',
  based_on: 'based_on',
  prequel: 'prequel',
  side_story: 'side_story',
  doujinshi: 'doujinshi',
  same_franchise: 'same_franchise',
  shared_universe: 'shared_universe',
  sequel: 'sequel',
  spin_off: 'spin_off',
  alternate_story: 'alternate_story',
  alternate_version: 'alternate_version',
  preserialization: 'preserialization',
  colored: 'colored',
  serialization: 'serialization',
} as const;

export interface MangaRelationRequest {
  targetManga?: string;
  relation?: MangaRelationRequestRelation;
}

export interface MangaRelationList {
  result?: string;
  response?: string;
  data?: MangaRelation[];
  limit?: number;
  offset?: number;
  total?: number;
}

export type MangaRelationResponseResult = typeof MangaRelationResponseResult[keyof typeof MangaRelationResponseResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MangaRelationResponseResult = {
  ok: 'ok',
  error: 'error',
} as const;

export interface MangaRelationResponse {
  result?: MangaRelationResponseResult;
  response?: string;
  data?: MangaRelation;
}

export type MangaRelationType = typeof MangaRelationType[keyof typeof MangaRelationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MangaRelationType = {
  manga_relation: 'manga_relation',
} as const;

export interface MangaRelation {
  id?: string;
  type?: MangaRelationType;
  attributes?: MangaRelationAttributes;
  relationships?: Relationship[];
}

export type MangaRelationAttributesRelation = typeof MangaRelationAttributesRelation[keyof typeof MangaRelationAttributesRelation];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MangaRelationAttributesRelation = {
  monochrome: 'monochrome',
  main_story: 'main_story',
  adapted_from: 'adapted_from',
  based_on: 'based_on',
  prequel: 'prequel',
  side_story: 'side_story',
  doujinshi: 'doujinshi',
  same_franchise: 'same_franchise',
  shared_universe: 'shared_universe',
  sequel: 'sequel',
  spin_off: 'spin_off',
  alternate_story: 'alternate_story',
  alternate_version: 'alternate_version',
  preserialization: 'preserialization',
  colored: 'colored',
  serialization: 'serialization',
} as const;

export interface MangaRelationAttributes {
  relation?: MangaRelationAttributesRelation;
  /** @minimum 1 */
  version?: number;
}

export interface MangaList {
  result?: string;
  response?: string;
  data?: Manga[];
  limit?: number;
  offset?: number;
  total?: number;
}

export interface CustomListList {
  result?: string;
  response?: string;
  data?: CustomList[];
  limit?: number;
  offset?: number;
  total?: number;
}

export interface UserList {
  result?: string;
  response?: string;
  data?: User[];
  limit?: number;
  offset?: number;
  total?: number;
}

export type UploadSessionType = typeof UploadSessionType[keyof typeof UploadSessionType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UploadSessionType = {
  upload_session: 'upload_session',
} as const;

export interface UploadSession {
  id?: string;
  type?: UploadSessionType;
  attributes?: UploadSessionAttributes;
}

export interface UploadSessionAttributes {
  isCommitted?: boolean;
  isProcessed?: boolean;
  isDeleted?: boolean;
  /** @minimum 1 */
  version?: number;
  createdAt?: string;
  updatedAt?: string;
}

export type UploadSessionFileType = typeof UploadSessionFileType[keyof typeof UploadSessionFileType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UploadSessionFileType = {
  upload_session_file: 'upload_session_file',
} as const;

export interface UploadSessionFile {
  id?: string;
  type?: UploadSessionFileType;
  attributes?: UploadSessionFileAttributes;
}

export type UploadSessionFileAttributesSource = typeof UploadSessionFileAttributesSource[keyof typeof UploadSessionFileAttributesSource];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UploadSessionFileAttributesSource = {
  local: 'local',
  remote: 'remote',
} as const;

export interface UploadSessionFileAttributes {
  originalFileName?: string;
  fileHash?: string;
  fileSize?: number;
  mimeType?: string;
  source?: UploadSessionFileAttributesSource;
  /** @minimum 1 */
  version?: number;
}

export type ChapterReadMarkerBatch = (unknown & {
  chapterIdsRead?: string[];
  chapterIdsUnread?: string[];
}) | (unknown & {
  chapterIdsRead?: string[];
  chapterIdsUnread?: string[];
});

export interface BeginUploadSession {
  /** @maxItems 10 */
  groups: string[];
  /**
   * @minLength 36
   * @maxLength 36
   */
  manga: string;
}

export interface BeginEditSession {
  /** @minimum 1 */
  version: number;
}

export interface CommitUploadSession {
  chapterDraft?: ChapterDraft;
  /**
   * ordered list of Upload Session File ids
   * @minItems 1
   * @maxItems 500
   */
  pageOrder?: string[];
}

export interface ChapterDraft {
  volume: ChapterVolume;
  chapter: ChapterVolume;
  /**
   * @maxLength 255
   * @nullable
   */
  title: string | null;
  /** @pattern ^[a-z]{2}(-[a-z]{2})?$ */
  translatedLanguage: string;
  /**
   * @maxLength 512
   * @nullable
   * @pattern ^https?://
   */
  externalUrl?: string | null;
  /** @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$ */
  publishAt?: string;
}

export type ReportListResponseResult = typeof ReportListResponseResult[keyof typeof ReportListResponseResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReportListResponseResult = {
  ok: 'ok',
  error: 'error',
} as const;

export interface ReportListResponse {
  result?: ReportListResponseResult;
  response?: string;
  data?: Report[];
  limit?: number;
  offset?: number;
  total?: number;
}

export type ReportType = typeof ReportType[keyof typeof ReportType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReportType = {
  report: 'report',
} as const;

export interface Report {
  id?: string;
  type?: ReportType;
  attributes?: ReportAttributes;
  relationships?: Relationship[];
}

export type ReportAttributesStatus = typeof ReportAttributesStatus[keyof typeof ReportAttributesStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReportAttributesStatus = {
  waiting: 'waiting',
  accepted: 'accepted',
  refused: 'refused',
  autoresolved: 'autoresolved',
} as const;

export interface ReportAttributes {
  details?: string;
  objectId?: string;
  status?: ReportAttributesStatus;
  createdAt?: string;
}

export type ForumsThreadResponseDataAttributes = {
  /** The number of replies so far in the forums thread returned */
  repliesCount?: number;
};

export type ForumsThreadResponseData = {
  type?: string;
  /** The id for the thread on the forums, accessible at `https://forums.mangadex.org/threads/:id` */
  id?: number;
  attributes?: ForumsThreadResponseDataAttributes;
};

export interface ForumsThreadResponse {
  result?: string;
  response?: string;
  data?: ForumsThreadResponseData;
}

export type ReferenceExpansionAuthorItem = typeof ReferenceExpansionAuthorItem[keyof typeof ReferenceExpansionAuthorItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReferenceExpansionAuthorItem = {
  manga: 'manga',
} as const;

/**
 * Reference expansion options for author/artist entities or lists
 */
export type ReferenceExpansionAuthor = ReferenceExpansionAuthorItem[];

export type ReferenceExpansionApiClientItem = typeof ReferenceExpansionApiClientItem[keyof typeof ReferenceExpansionApiClientItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReferenceExpansionApiClientItem = {
  creator: 'creator',
} as const;

/**
 * Reference expansion options for api_client entities or lists
 */
export type ReferenceExpansionApiClient = ReferenceExpansionApiClientItem[];

export type ReferenceExpansionChapterItem = typeof ReferenceExpansionChapterItem[keyof typeof ReferenceExpansionChapterItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReferenceExpansionChapterItem = {
  manga: 'manga',
  scanlation_group: 'scanlation_group',
  user: 'user',
} as const;

/**
 * Reference expansion options for chapter entities or lists
 */
export type ReferenceExpansionChapter = ReferenceExpansionChapterItem[];

export type ReferenceExpansionCoverArtItem = typeof ReferenceExpansionCoverArtItem[keyof typeof ReferenceExpansionCoverArtItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReferenceExpansionCoverArtItem = {
  manga: 'manga',
  user: 'user',
} as const;

/**
 * Reference expansion options for cover art entities or lists
 */
export type ReferenceExpansionCoverArt = ReferenceExpansionCoverArtItem[];

export type ReferenceExpansionMangaItem = typeof ReferenceExpansionMangaItem[keyof typeof ReferenceExpansionMangaItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReferenceExpansionMangaItem = {
  manga: 'manga',
  cover_art: 'cover_art',
  author: 'author',
  artist: 'artist',
  tag: 'tag',
  creator: 'creator',
} as const;

/**
 * Reference expansion options for manga entities or lists
 */
export type ReferenceExpansionManga = ReferenceExpansionMangaItem[];

export type ReferenceExpansionMangaRelationItem = typeof ReferenceExpansionMangaRelationItem[keyof typeof ReferenceExpansionMangaRelationItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReferenceExpansionMangaRelationItem = {
  manga: 'manga',
} as const;

/**
 * Reference expansion options for manga relation entities or lists
 */
export type ReferenceExpansionMangaRelation = ReferenceExpansionMangaRelationItem[];

export type ReferenceExpansionReportItem = typeof ReferenceExpansionReportItem[keyof typeof ReferenceExpansionReportItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReferenceExpansionReportItem = {
  user: 'user',
  reason: 'reason',
} as const;

/**
 * Reference expansion options for user report entities or lists
 */
export type ReferenceExpansionReport = ReferenceExpansionReportItem[];

export type ReferenceExpansionScanlationGroupItem = typeof ReferenceExpansionScanlationGroupItem[keyof typeof ReferenceExpansionScanlationGroupItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReferenceExpansionScanlationGroupItem = {
  leader: 'leader',
  member: 'member',
} as const;

/**
 * Reference expansion options for scanlation group entities or lists
 */
export type ReferenceExpansionScanlationGroup = ReferenceExpansionScanlationGroupItem[];

/**
 * Comments-related statistics of an entity.
If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.

 * @nullable
 */
export type StatisticsDetailsComments = {
  /**
   * The id of the thread backing the comments for that entity on the MangaDex Forums.
   * @minimum 1
   */
  threadId?: number;
  /**
   * The number of replies on the MangaDex Forums thread backing this entity's comments. This excludes the initial comment that opens the thread, which is created by our systems.

   * @minimum 0
   */
  repliesCount?: number;
} | null;

export type GetSearchMangaParams = {
/**
 * @minimum 0
 * @maximum 100
 * @pattern ^\d+$
 */
limit?: number;
/**
 * @minimum 0
 * @pattern ^\d+$
 */
offset?: number;
title?: string;
authorOrArtist?: string;
'authors[]'?: string[];
'artists[]'?: string[];
/**
 * Year of release or none
 */
year?: number | 'none';
'includedTags[]'?: string[];
includedTagsMode?: GetSearchMangaIncludedTagsMode;
'excludedTags[]'?: string[];
excludedTagsMode?: GetSearchMangaExcludedTagsMode;
'status[]'?: GetSearchMangaStatusItem[];
'originalLanguage[]'?: string[];
'excludedOriginalLanguage[]'?: string[];
'availableTranslatedLanguage[]'?: string[];
'publicationDemographic[]'?: GetSearchMangaPublicationDemographicItem[];
/**
 * Manga ids (limited to 100 per request)
 */
'ids[]'?: string[];
'contentRating[]'?: GetSearchMangaContentRatingItem[];
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
createdAtSince?: string;
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
updatedAtSince?: string;
order?: {
  title?: GetSearchMangaOrderTitle;
  year?: GetSearchMangaOrderYear;
  createdAt?: GetSearchMangaOrderCreatedAt;
  updatedAt?: GetSearchMangaOrderUpdatedAt;
  latestUploadedChapter?: GetSearchMangaOrderLatestUploadedChapter;
  followedCount?: GetSearchMangaOrderFollowedCount;
  relevance?: GetSearchMangaOrderRelevance;
  rating?: GetSearchMangaOrderRating;
};
'includes[]'?: ReferenceExpansionManga;
hasAvailableChapters?: GetSearchMangaHasAvailableChapters;
hasUnavailableChapters?: GetSearchMangaHasUnavailableChapters;
group?: string;
};

export type GetSearchMangaIncludedTagsMode = typeof GetSearchMangaIncludedTagsMode[keyof typeof GetSearchMangaIncludedTagsMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaIncludedTagsMode = {
  AND: 'AND',
  OR: 'OR',
} as const;

export type GetSearchMangaExcludedTagsMode = typeof GetSearchMangaExcludedTagsMode[keyof typeof GetSearchMangaExcludedTagsMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaExcludedTagsMode = {
  AND: 'AND',
  OR: 'OR',
} as const;

export type GetSearchMangaStatusItem = typeof GetSearchMangaStatusItem[keyof typeof GetSearchMangaStatusItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaStatusItem = {
  ongoing: 'ongoing',
  completed: 'completed',
  hiatus: 'hiatus',
  cancelled: 'cancelled',
} as const;

export type GetSearchMangaPublicationDemographicItem = typeof GetSearchMangaPublicationDemographicItem[keyof typeof GetSearchMangaPublicationDemographicItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaPublicationDemographicItem = {
  shounen: 'shounen',
  shoujo: 'shoujo',
  josei: 'josei',
  seinen: 'seinen',
  none: 'none',
} as const;

export type GetSearchMangaContentRatingItem = typeof GetSearchMangaContentRatingItem[keyof typeof GetSearchMangaContentRatingItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaContentRatingItem = {
  safe: 'safe',
  suggestive: 'suggestive',
  erotica: 'erotica',
  pornographic: 'pornographic',
} as const;

export type GetSearchMangaOrderTitle = typeof GetSearchMangaOrderTitle[keyof typeof GetSearchMangaOrderTitle];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaOrderTitle = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetSearchMangaOrderYear = typeof GetSearchMangaOrderYear[keyof typeof GetSearchMangaOrderYear];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaOrderYear = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetSearchMangaOrderCreatedAt = typeof GetSearchMangaOrderCreatedAt[keyof typeof GetSearchMangaOrderCreatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaOrderCreatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetSearchMangaOrderUpdatedAt = typeof GetSearchMangaOrderUpdatedAt[keyof typeof GetSearchMangaOrderUpdatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaOrderUpdatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetSearchMangaOrderLatestUploadedChapter = typeof GetSearchMangaOrderLatestUploadedChapter[keyof typeof GetSearchMangaOrderLatestUploadedChapter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaOrderLatestUploadedChapter = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetSearchMangaOrderFollowedCount = typeof GetSearchMangaOrderFollowedCount[keyof typeof GetSearchMangaOrderFollowedCount];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaOrderFollowedCount = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetSearchMangaOrderRelevance = typeof GetSearchMangaOrderRelevance[keyof typeof GetSearchMangaOrderRelevance];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaOrderRelevance = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetSearchMangaOrderRating = typeof GetSearchMangaOrderRating[keyof typeof GetSearchMangaOrderRating];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaOrderRating = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetSearchMangaHasAvailableChapters = typeof GetSearchMangaHasAvailableChapters[keyof typeof GetSearchMangaHasAvailableChapters];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaHasAvailableChapters = {
  NUMBER_0: '0',
  NUMBER_1: '1',
  true: 'true',
  false: 'false',
} as const;

export type GetSearchMangaHasUnavailableChapters = typeof GetSearchMangaHasUnavailableChapters[keyof typeof GetSearchMangaHasUnavailableChapters];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchMangaHasUnavailableChapters = {
  NUMBER_0: '0',
  NUMBER_1: '1',
} as const;

export type GetMangaAggregateParams = {
'translatedLanguage[]'?: string[];
'groups[]'?: string[];
};

export type GetMangaAggregate200VolumesChapters = {[key: string]: {
  chapter?: string;
  id?: string;
  others?: string[];
  count?: number;
}};

export type GetMangaAggregate200Volumes = {[key: string]: {
  volume?: string;
  count?: number;
  chapters?: GetMangaAggregate200VolumesChapters;
}};

export type GetMangaAggregate200 = {
  result?: string;
  volumes?: GetMangaAggregate200Volumes;
};

export type GetMangaIdParams = {
'includes[]'?: ReferenceExpansionManga;
};

export type PutMangaIdBodyAllOf = {
  artists?: string[];
  authors?: string[];
};

export type PutMangaIdBody = MangaEdit & PutMangaIdBodyAllOf;

export type GetListApiclientsParams = {
/**
 * @minimum 0
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
state?: GetListApiclientsState;
name?: string;
'includes[]'?: ReferenceExpansionApiClient;
order?: {
  name?: GetListApiclientsOrderName;
  createdAt?: GetListApiclientsOrderCreatedAt;
  updatedAt?: GetListApiclientsOrderUpdatedAt;
};
};

export type GetListApiclientsState = typeof GetListApiclientsState[keyof typeof GetListApiclientsState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListApiclientsState = {
  requested: 'requested',
  approved: 'approved',
  rejected: 'rejected',
  autoapproved: 'autoapproved',
} as const;

export type GetListApiclientsOrderName = typeof GetListApiclientsOrderName[keyof typeof GetListApiclientsOrderName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListApiclientsOrderName = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetListApiclientsOrderCreatedAt = typeof GetListApiclientsOrderCreatedAt[keyof typeof GetListApiclientsOrderCreatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListApiclientsOrderCreatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetListApiclientsOrderUpdatedAt = typeof GetListApiclientsOrderUpdatedAt[keyof typeof GetListApiclientsOrderUpdatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListApiclientsOrderUpdatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetApiclientParams = {
'includes[]'?: ReferenceExpansionApiClient;
};

export type DeleteApiclientParams = {
/**
 * @pattern ^\d+$
 */
version?: string;
};

export type DeleteApiclient200 = {
  result?: string;
};

export type GetApiclientSecret200Result = typeof GetApiclientSecret200Result[keyof typeof GetApiclientSecret200Result];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetApiclientSecret200Result = {
  ok: 'ok',
} as const;

export type GetApiclientSecret200 = {
  result?: GetApiclientSecret200Result;
  data?: string;
};

export type PostRegenerateApiclientSecretBody = { [key: string]: unknown };

export type PostRegenerateApiclientSecret200Result = typeof PostRegenerateApiclientSecret200Result[keyof typeof PostRegenerateApiclientSecret200Result];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostRegenerateApiclientSecret200Result = {
  ok: 'ok',
} as const;

export type PostRegenerateApiclientSecret200 = {
  result?: PostRegenerateApiclientSecret200Result;
  data?: string;
};

export type GetSearchGroupParams = {
/**
 * @minimum 0
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
/**
 * ScanlationGroup ids (limited to 100 per request)
 */
'ids[]'?: string[];
name?: string;
focusedLanguage?: string;
'includes[]'?: ReferenceExpansionScanlationGroup;
order?: {
  name?: GetSearchGroupOrderName;
  createdAt?: GetSearchGroupOrderCreatedAt;
  updatedAt?: GetSearchGroupOrderUpdatedAt;
  followedCount?: GetSearchGroupOrderFollowedCount;
  relevance?: GetSearchGroupOrderRelevance;
};
};

export type GetSearchGroupOrderName = typeof GetSearchGroupOrderName[keyof typeof GetSearchGroupOrderName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchGroupOrderName = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetSearchGroupOrderCreatedAt = typeof GetSearchGroupOrderCreatedAt[keyof typeof GetSearchGroupOrderCreatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchGroupOrderCreatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetSearchGroupOrderUpdatedAt = typeof GetSearchGroupOrderUpdatedAt[keyof typeof GetSearchGroupOrderUpdatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchGroupOrderUpdatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetSearchGroupOrderFollowedCount = typeof GetSearchGroupOrderFollowedCount[keyof typeof GetSearchGroupOrderFollowedCount];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchGroupOrderFollowedCount = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetSearchGroupOrderRelevance = typeof GetSearchGroupOrderRelevance[keyof typeof GetSearchGroupOrderRelevance];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetSearchGroupOrderRelevance = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetGroupIdParams = {
'includes[]'?: ReferenceExpansionScanlationGroup;
};

export type FollowListIdBody = { [key: string]: unknown };

export type FollowListId200Result = typeof FollowListId200Result[keyof typeof FollowListId200Result];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FollowListId200Result = {
  ok: 'ok',
} as const;

export type FollowListId200 = {
  result?: FollowListId200Result;
};

export type UnfollowListIdBody = { [key: string]: unknown };

export type UnfollowListId200Result = typeof UnfollowListId200Result[keyof typeof UnfollowListId200Result];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UnfollowListId200Result = {
  ok: 'ok',
} as const;

export type UnfollowListId200 = {
  result?: UnfollowListId200Result;
};

export type GetUserListParams = {
/**
 * @minimum 0
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
};

export type GetUserIdListParams = {
/**
 * @minimum 0
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
};

export type GetUserParams = {
/**
 * @minimum 0
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
/**
 * User ids (limited to 100 per request)
 */
'ids[]'?: string[];
username?: string;
order?: {
  username?: GetUserOrderUsername;
};
};

export type GetUserOrderUsername = typeof GetUserOrderUsername[keyof typeof GetUserOrderUsername];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserOrderUsername = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetChapterParams = {
/**
 * @minimum 0
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
/**
 * Chapter ids (limited to 100 per request)
 */
'ids[]'?: string[];
title?: string;
'groups[]'?: string[];
uploader?: string | string[];
manga?: string;
'volume[]'?: string | string[];
chapter?: string | string[];
'translatedLanguage[]'?: string[];
'originalLanguage[]'?: string[];
'excludedOriginalLanguage[]'?: string[];
'contentRating[]'?: GetChapterContentRatingItem[];
'excludedGroups[]'?: string[];
'excludedUploaders[]'?: string[];
includeFutureUpdates?: GetChapterIncludeFutureUpdates;
includeEmptyPages?: GetChapterIncludeEmptyPages;
includeFuturePublishAt?: GetChapterIncludeFuturePublishAt;
includeExternalUrl?: GetChapterIncludeExternalUrl;
includeUnavailable?: GetChapterIncludeUnavailable;
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
createdAtSince?: string;
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
updatedAtSince?: string;
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
publishAtSince?: string;
order?: {
  createdAt?: GetChapterOrderCreatedAt;
  updatedAt?: GetChapterOrderUpdatedAt;
  publishAt?: GetChapterOrderPublishAt;
  readableAt?: GetChapterOrderReadableAt;
  volume?: GetChapterOrderVolume;
  chapter?: GetChapterOrderChapter;
};
includes?: GetChapterIncludesItem[];
};

export type GetChapterContentRatingItem = typeof GetChapterContentRatingItem[keyof typeof GetChapterContentRatingItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetChapterContentRatingItem = {
  safe: 'safe',
  suggestive: 'suggestive',
  erotica: 'erotica',
  pornographic: 'pornographic',
} as const;

export type GetChapterIncludeFutureUpdates = typeof GetChapterIncludeFutureUpdates[keyof typeof GetChapterIncludeFutureUpdates];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetChapterIncludeFutureUpdates = {
  NUMBER_0: '0',
  NUMBER_1: '1',
} as const;

export type GetChapterIncludeEmptyPages = typeof GetChapterIncludeEmptyPages[keyof typeof GetChapterIncludeEmptyPages];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetChapterIncludeEmptyPages = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type GetChapterIncludeFuturePublishAt = typeof GetChapterIncludeFuturePublishAt[keyof typeof GetChapterIncludeFuturePublishAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetChapterIncludeFuturePublishAt = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type GetChapterIncludeExternalUrl = typeof GetChapterIncludeExternalUrl[keyof typeof GetChapterIncludeExternalUrl];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetChapterIncludeExternalUrl = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type GetChapterIncludeUnavailable = typeof GetChapterIncludeUnavailable[keyof typeof GetChapterIncludeUnavailable];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetChapterIncludeUnavailable = {
  NUMBER_0: '0',
  NUMBER_1: '1',
} as const;

export type GetChapterOrderCreatedAt = typeof GetChapterOrderCreatedAt[keyof typeof GetChapterOrderCreatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetChapterOrderCreatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetChapterOrderUpdatedAt = typeof GetChapterOrderUpdatedAt[keyof typeof GetChapterOrderUpdatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetChapterOrderUpdatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetChapterOrderPublishAt = typeof GetChapterOrderPublishAt[keyof typeof GetChapterOrderPublishAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetChapterOrderPublishAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetChapterOrderReadableAt = typeof GetChapterOrderReadableAt[keyof typeof GetChapterOrderReadableAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetChapterOrderReadableAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetChapterOrderVolume = typeof GetChapterOrderVolume[keyof typeof GetChapterOrderVolume];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetChapterOrderVolume = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetChapterOrderChapter = typeof GetChapterOrderChapter[keyof typeof GetChapterOrderChapter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetChapterOrderChapter = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetChapterIncludesItem = typeof GetChapterIncludesItem[keyof typeof GetChapterIncludesItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetChapterIncludesItem = {
  manga: 'manga',
  scanlation_group: 'scanlation_group',
  user: 'user',
} as const;

export type GetChapterIdParams = {
'includes[]'?: ReferenceExpansionChapter;
};

export type GetUserFollowsMangaFeedParams = {
/**
 * @minimum 1
 * @maximum 500
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
'translatedLanguage[]'?: string[];
'originalLanguage[]'?: string[];
'excludedOriginalLanguage[]'?: string[];
'contentRating[]'?: GetUserFollowsMangaFeedContentRatingItem[];
'excludedGroups[]'?: string[];
'excludedUploaders[]'?: string[];
includeFutureUpdates?: GetUserFollowsMangaFeedIncludeFutureUpdates;
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
createdAtSince?: string;
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
updatedAtSince?: string;
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
publishAtSince?: string;
order?: {
  createdAt?: GetUserFollowsMangaFeedOrderCreatedAt;
  updatedAt?: GetUserFollowsMangaFeedOrderUpdatedAt;
  publishAt?: GetUserFollowsMangaFeedOrderPublishAt;
  readableAt?: GetUserFollowsMangaFeedOrderReadableAt;
  volume?: GetUserFollowsMangaFeedOrderVolume;
  chapter?: GetUserFollowsMangaFeedOrderChapter;
};
'includes[]'?: ReferenceExpansionChapter;
includeEmptyPages?: GetUserFollowsMangaFeedIncludeEmptyPages;
includeFuturePublishAt?: GetUserFollowsMangaFeedIncludeFuturePublishAt;
includeExternalUrl?: GetUserFollowsMangaFeedIncludeExternalUrl;
includeUnavailable?: GetUserFollowsMangaFeedIncludeUnavailable;
};

export type GetUserFollowsMangaFeedContentRatingItem = typeof GetUserFollowsMangaFeedContentRatingItem[keyof typeof GetUserFollowsMangaFeedContentRatingItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserFollowsMangaFeedContentRatingItem = {
  safe: 'safe',
  suggestive: 'suggestive',
  erotica: 'erotica',
  pornographic: 'pornographic',
} as const;

export type GetUserFollowsMangaFeedIncludeFutureUpdates = typeof GetUserFollowsMangaFeedIncludeFutureUpdates[keyof typeof GetUserFollowsMangaFeedIncludeFutureUpdates];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserFollowsMangaFeedIncludeFutureUpdates = {
  NUMBER_0: '0',
  NUMBER_1: '1',
} as const;

export type GetUserFollowsMangaFeedOrderCreatedAt = typeof GetUserFollowsMangaFeedOrderCreatedAt[keyof typeof GetUserFollowsMangaFeedOrderCreatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserFollowsMangaFeedOrderCreatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetUserFollowsMangaFeedOrderUpdatedAt = typeof GetUserFollowsMangaFeedOrderUpdatedAt[keyof typeof GetUserFollowsMangaFeedOrderUpdatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserFollowsMangaFeedOrderUpdatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetUserFollowsMangaFeedOrderPublishAt = typeof GetUserFollowsMangaFeedOrderPublishAt[keyof typeof GetUserFollowsMangaFeedOrderPublishAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserFollowsMangaFeedOrderPublishAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetUserFollowsMangaFeedOrderReadableAt = typeof GetUserFollowsMangaFeedOrderReadableAt[keyof typeof GetUserFollowsMangaFeedOrderReadableAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserFollowsMangaFeedOrderReadableAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetUserFollowsMangaFeedOrderVolume = typeof GetUserFollowsMangaFeedOrderVolume[keyof typeof GetUserFollowsMangaFeedOrderVolume];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserFollowsMangaFeedOrderVolume = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetUserFollowsMangaFeedOrderChapter = typeof GetUserFollowsMangaFeedOrderChapter[keyof typeof GetUserFollowsMangaFeedOrderChapter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserFollowsMangaFeedOrderChapter = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetUserFollowsMangaFeedIncludeEmptyPages = typeof GetUserFollowsMangaFeedIncludeEmptyPages[keyof typeof GetUserFollowsMangaFeedIncludeEmptyPages];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserFollowsMangaFeedIncludeEmptyPages = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type GetUserFollowsMangaFeedIncludeFuturePublishAt = typeof GetUserFollowsMangaFeedIncludeFuturePublishAt[keyof typeof GetUserFollowsMangaFeedIncludeFuturePublishAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserFollowsMangaFeedIncludeFuturePublishAt = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type GetUserFollowsMangaFeedIncludeExternalUrl = typeof GetUserFollowsMangaFeedIncludeExternalUrl[keyof typeof GetUserFollowsMangaFeedIncludeExternalUrl];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserFollowsMangaFeedIncludeExternalUrl = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type GetUserFollowsMangaFeedIncludeUnavailable = typeof GetUserFollowsMangaFeedIncludeUnavailable[keyof typeof GetUserFollowsMangaFeedIncludeUnavailable];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserFollowsMangaFeedIncludeUnavailable = {
  NUMBER_0: '0',
  NUMBER_1: '1',
} as const;

export type GetListIdFeedParams = {
/**
 * @minimum 1
 * @maximum 500
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
'translatedLanguage[]'?: string[];
'originalLanguage[]'?: string[];
'excludedOriginalLanguage[]'?: string[];
'contentRating[]'?: GetListIdFeedContentRatingItem[];
'excludedGroups[]'?: string[];
'excludedUploaders[]'?: string[];
includeFutureUpdates?: GetListIdFeedIncludeFutureUpdates;
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
createdAtSince?: string;
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
updatedAtSince?: string;
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
publishAtSince?: string;
order?: {
  createdAt?: GetListIdFeedOrderCreatedAt;
  updatedAt?: GetListIdFeedOrderUpdatedAt;
  publishAt?: GetListIdFeedOrderPublishAt;
  readableAt?: GetListIdFeedOrderReadableAt;
  volume?: GetListIdFeedOrderVolume;
  chapter?: GetListIdFeedOrderChapter;
};
'includes[]'?: ReferenceExpansionChapter;
includeEmptyPages?: GetListIdFeedIncludeEmptyPages;
includeFuturePublishAt?: GetListIdFeedIncludeFuturePublishAt;
includeExternalUrl?: GetListIdFeedIncludeExternalUrl;
includeUnavailable?: GetListIdFeedIncludeUnavailable;
};

export type GetListIdFeedContentRatingItem = typeof GetListIdFeedContentRatingItem[keyof typeof GetListIdFeedContentRatingItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListIdFeedContentRatingItem = {
  safe: 'safe',
  suggestive: 'suggestive',
  erotica: 'erotica',
  pornographic: 'pornographic',
} as const;

export type GetListIdFeedIncludeFutureUpdates = typeof GetListIdFeedIncludeFutureUpdates[keyof typeof GetListIdFeedIncludeFutureUpdates];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListIdFeedIncludeFutureUpdates = {
  NUMBER_0: '0',
  NUMBER_1: '1',
} as const;

export type GetListIdFeedOrderCreatedAt = typeof GetListIdFeedOrderCreatedAt[keyof typeof GetListIdFeedOrderCreatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListIdFeedOrderCreatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetListIdFeedOrderUpdatedAt = typeof GetListIdFeedOrderUpdatedAt[keyof typeof GetListIdFeedOrderUpdatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListIdFeedOrderUpdatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetListIdFeedOrderPublishAt = typeof GetListIdFeedOrderPublishAt[keyof typeof GetListIdFeedOrderPublishAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListIdFeedOrderPublishAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetListIdFeedOrderReadableAt = typeof GetListIdFeedOrderReadableAt[keyof typeof GetListIdFeedOrderReadableAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListIdFeedOrderReadableAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetListIdFeedOrderVolume = typeof GetListIdFeedOrderVolume[keyof typeof GetListIdFeedOrderVolume];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListIdFeedOrderVolume = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetListIdFeedOrderChapter = typeof GetListIdFeedOrderChapter[keyof typeof GetListIdFeedOrderChapter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListIdFeedOrderChapter = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetListIdFeedIncludeEmptyPages = typeof GetListIdFeedIncludeEmptyPages[keyof typeof GetListIdFeedIncludeEmptyPages];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListIdFeedIncludeEmptyPages = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type GetListIdFeedIncludeFuturePublishAt = typeof GetListIdFeedIncludeFuturePublishAt[keyof typeof GetListIdFeedIncludeFuturePublishAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListIdFeedIncludeFuturePublishAt = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type GetListIdFeedIncludeExternalUrl = typeof GetListIdFeedIncludeExternalUrl[keyof typeof GetListIdFeedIncludeExternalUrl];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListIdFeedIncludeExternalUrl = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type GetListIdFeedIncludeUnavailable = typeof GetListIdFeedIncludeUnavailable[keyof typeof GetListIdFeedIncludeUnavailable];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetListIdFeedIncludeUnavailable = {
  NUMBER_0: '0',
  NUMBER_1: '1',
} as const;

export type GetCoverParams = {
/**
 * @minimum 0
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
/**
 * Manga ids (limited to 100 per request)
 */
'manga[]'?: string[];
/**
 * Covers ids (limited to 100 per request)
 */
'ids[]'?: string[];
/**
 * User ids (limited to 100 per request)
 */
'uploaders[]'?: string[];
/**
 * Locales of cover art (limited to 100 per request)
 */
'locales[]'?: string[];
order?: {
  createdAt?: GetCoverOrderCreatedAt;
  updatedAt?: GetCoverOrderUpdatedAt;
  volume?: GetCoverOrderVolume;
};
'includes[]'?: ReferenceExpansionCoverArt;
};

export type GetCoverOrderCreatedAt = typeof GetCoverOrderCreatedAt[keyof typeof GetCoverOrderCreatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCoverOrderCreatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetCoverOrderUpdatedAt = typeof GetCoverOrderUpdatedAt[keyof typeof GetCoverOrderUpdatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCoverOrderUpdatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetCoverOrderVolume = typeof GetCoverOrderVolume[keyof typeof GetCoverOrderVolume];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCoverOrderVolume = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type UploadCoverBody = {
  file?: Blob;
  volume?: CoverVolume;
  /** */
  description?: string;
  /**
   * @pattern ^[a-z]{2}(-[a-z]{2})?$
   */
  locale?: string;
};

export type GetCoverIdParams = {
'includes[]'?: ReferenceExpansionCoverArt;
};

export type GetAuthorParams = {
/**
 * @minimum 0
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
/**
 * Author ids (limited to 100 per request)
 */
'ids[]'?: string[];
name?: string;
order?: {
  name?: GetAuthorOrderName;
};
'includes[]'?: ReferenceExpansionAuthor;
};

export type GetAuthorOrderName = typeof GetAuthorOrderName[keyof typeof GetAuthorOrderName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetAuthorOrderName = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetAuthorIdParams = {
'includes[]'?: ReferenceExpansionAuthor;
};

export type GetMangaIdFeedParams = {
/**
 * @minimum 1
 * @maximum 500
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
'translatedLanguage[]'?: string[];
'originalLanguage[]'?: string[];
'excludedOriginalLanguage[]'?: string[];
'contentRating[]'?: GetMangaIdFeedContentRatingItem[];
'excludedGroups[]'?: string[];
'excludedUploaders[]'?: string[];
includeFutureUpdates?: GetMangaIdFeedIncludeFutureUpdates;
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
createdAtSince?: string;
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
updatedAtSince?: string;
/**
 * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
 * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
 */
publishAtSince?: string;
order?: {
  createdAt?: GetMangaIdFeedOrderCreatedAt;
  updatedAt?: GetMangaIdFeedOrderUpdatedAt;
  publishAt?: GetMangaIdFeedOrderPublishAt;
  readableAt?: GetMangaIdFeedOrderReadableAt;
  volume?: GetMangaIdFeedOrderVolume;
  chapter?: GetMangaIdFeedOrderChapter;
};
'includes[]'?: ReferenceExpansionChapter;
includeEmptyPages?: GetMangaIdFeedIncludeEmptyPages;
includeFuturePublishAt?: GetMangaIdFeedIncludeFuturePublishAt;
includeExternalUrl?: GetMangaIdFeedIncludeExternalUrl;
includeUnavailable?: GetMangaIdFeedIncludeUnavailable;
};

export type GetMangaIdFeedContentRatingItem = typeof GetMangaIdFeedContentRatingItem[keyof typeof GetMangaIdFeedContentRatingItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaIdFeedContentRatingItem = {
  safe: 'safe',
  suggestive: 'suggestive',
  erotica: 'erotica',
  pornographic: 'pornographic',
} as const;

export type GetMangaIdFeedIncludeFutureUpdates = typeof GetMangaIdFeedIncludeFutureUpdates[keyof typeof GetMangaIdFeedIncludeFutureUpdates];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaIdFeedIncludeFutureUpdates = {
  NUMBER_0: '0',
  NUMBER_1: '1',
} as const;

export type GetMangaIdFeedOrderCreatedAt = typeof GetMangaIdFeedOrderCreatedAt[keyof typeof GetMangaIdFeedOrderCreatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaIdFeedOrderCreatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetMangaIdFeedOrderUpdatedAt = typeof GetMangaIdFeedOrderUpdatedAt[keyof typeof GetMangaIdFeedOrderUpdatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaIdFeedOrderUpdatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetMangaIdFeedOrderPublishAt = typeof GetMangaIdFeedOrderPublishAt[keyof typeof GetMangaIdFeedOrderPublishAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaIdFeedOrderPublishAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetMangaIdFeedOrderReadableAt = typeof GetMangaIdFeedOrderReadableAt[keyof typeof GetMangaIdFeedOrderReadableAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaIdFeedOrderReadableAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetMangaIdFeedOrderVolume = typeof GetMangaIdFeedOrderVolume[keyof typeof GetMangaIdFeedOrderVolume];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaIdFeedOrderVolume = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetMangaIdFeedOrderChapter = typeof GetMangaIdFeedOrderChapter[keyof typeof GetMangaIdFeedOrderChapter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaIdFeedOrderChapter = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetMangaIdFeedIncludeEmptyPages = typeof GetMangaIdFeedIncludeEmptyPages[keyof typeof GetMangaIdFeedIncludeEmptyPages];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaIdFeedIncludeEmptyPages = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type GetMangaIdFeedIncludeFuturePublishAt = typeof GetMangaIdFeedIncludeFuturePublishAt[keyof typeof GetMangaIdFeedIncludeFuturePublishAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaIdFeedIncludeFuturePublishAt = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type GetMangaIdFeedIncludeExternalUrl = typeof GetMangaIdFeedIncludeExternalUrl[keyof typeof GetMangaIdFeedIncludeExternalUrl];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaIdFeedIncludeExternalUrl = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type GetMangaIdFeedIncludeUnavailable = typeof GetMangaIdFeedIncludeUnavailable[keyof typeof GetMangaIdFeedIncludeUnavailable];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaIdFeedIncludeUnavailable = {
  NUMBER_0: '0',
  NUMBER_1: '1',
} as const;

export type GetMangaChapterReadmarkers200Result = typeof GetMangaChapterReadmarkers200Result[keyof typeof GetMangaChapterReadmarkers200Result];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaChapterReadmarkers200Result = {
  ok: 'ok',
} as const;

export type GetMangaChapterReadmarkers200 = {
  result?: GetMangaChapterReadmarkers200Result;
  data?: string[];
};

export type PostMangaChapterReadmarkersParams = {
/**
 * Adding this will cause the chapter to be stored in the user's reading history
 */
updateHistory?: boolean;
};

export type PostMangaChapterReadmarkers200Result = typeof PostMangaChapterReadmarkers200Result[keyof typeof PostMangaChapterReadmarkers200Result];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostMangaChapterReadmarkers200Result = {
  ok: 'ok',
} as const;

export type PostMangaChapterReadmarkers200 = {
  result?: PostMangaChapterReadmarkers200Result;
};

export type GetMangaChapterReadmarkers2Params = {
/**
 * Manga ids
 */
'ids[]': string[];
/**
 * Group results by manga ids
 */
grouped?: boolean;
};

export type GetMangaChapterReadmarkers2200Result = typeof GetMangaChapterReadmarkers2200Result[keyof typeof GetMangaChapterReadmarkers2200Result];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaChapterReadmarkers2200Result = {
  ok: 'ok',
} as const;

export type GetMangaChapterReadmarkers2200DataOneOf = {[key: string]: string[]};

export type GetMangaChapterReadmarkers2200Data = string[] | GetMangaChapterReadmarkers2200DataOneOf;

export type GetMangaChapterReadmarkers2200 = {
  result?: GetMangaChapterReadmarkers2200Result;
  data?: GetMangaChapterReadmarkers2200Data;
};

export type GetMangaRandomParams = {
'includes[]'?: ReferenceExpansionManga;
'contentRating[]'?: GetMangaRandomContentRatingItem[];
'includedTags[]'?: string[];
includedTagsMode?: GetMangaRandomIncludedTagsMode;
'excludedTags[]'?: string[];
excludedTagsMode?: GetMangaRandomExcludedTagsMode;
};

export type GetMangaRandomContentRatingItem = typeof GetMangaRandomContentRatingItem[keyof typeof GetMangaRandomContentRatingItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaRandomContentRatingItem = {
  safe: 'safe',
  suggestive: 'suggestive',
  erotica: 'erotica',
  pornographic: 'pornographic',
} as const;

export type GetMangaRandomIncludedTagsMode = typeof GetMangaRandomIncludedTagsMode[keyof typeof GetMangaRandomIncludedTagsMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaRandomIncludedTagsMode = {
  AND: 'AND',
  OR: 'OR',
} as const;

export type GetMangaRandomExcludedTagsMode = typeof GetMangaRandomExcludedTagsMode[keyof typeof GetMangaRandomExcludedTagsMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaRandomExcludedTagsMode = {
  AND: 'AND',
  OR: 'OR',
} as const;

export type GetAtHomeServerChapterIdParams = {
/**
 * Force selecting from MangaDex@Home servers that use the standard HTTPS port 443.

While the conventional port for HTTPS traffic is 443 and servers are encouraged to use it, it is not a hard requirement as it technically isn't
anything special.

However, some misbehaving school/office network will at time block traffic to non-standard ports, and setting this flag to `true` will ensure
selection of a server that uses these.
 */
forcePort443?: boolean;
};

export type GetAtHomeServerChapterId200Chapter = {
  hash?: string;
  data?: string[];
  dataSaver?: string[];
};

export type GetAtHomeServerChapterId200 = {
  result?: string;
  /** The base URL to construct final image URLs from.
The URL returned is valid for the requested chapter only, and for a duration of 15 minutes from the time of the response. */
  baseUrl?: string;
  chapter?: GetAtHomeServerChapterId200Chapter;
};

export type GetUserFollowsGroupParams = {
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
'includes[]'?: ReferenceExpansionScanlationGroup;
};

export type GetUserFollowsUserParams = {
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
};

export type GetUserFollowsMangaParams = {
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
'includes[]'?: ReferenceExpansionManga;
};

export type GetUserFollowsListParams = {
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
};

export type GetMangaStatusParams = {
/**
 * Used to filter the list by given status
 */
status?: GetMangaStatusStatus;
};

export type GetMangaStatusStatus = typeof GetMangaStatusStatus[keyof typeof GetMangaStatusStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaStatusStatus = {
  reading: 'reading',
  on_hold: 'on_hold',
  plan_to_read: 'plan_to_read',
  dropped: 'dropped',
  re_reading: 're_reading',
  completed: 'completed',
} as const;

export type GetMangaStatus200Statuses = {[key: string]: 'reading' | 'on_hold' | 'plan_to_read' | 'dropped' | 're_reading' | 'completed'};

export type GetMangaStatus200 = {
  result?: string;
  statuses?: GetMangaStatus200Statuses;
};

export type GetMangaIdStatus200Status = typeof GetMangaIdStatus200Status[keyof typeof GetMangaIdStatus200Status];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaIdStatus200Status = {
  reading: 'reading',
  on_hold: 'on_hold',
  plan_to_read: 'plan_to_read',
  dropped: 'dropped',
  re_reading: 're_reading',
  completed: 'completed',
} as const;

export type GetMangaIdStatus200 = {
  result?: string;
  status?: GetMangaIdStatus200Status;
};

export type GetMangaIdDraftParams = {
'includes[]'?: ReferenceExpansionManga;
};

export type CommitMangaDraftBody = {
  /** @minimum 1 */
  version?: number;
};

export type GetMangaDraftsParams = {
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
state?: GetMangaDraftsState;
order?: {
  title?: GetMangaDraftsOrderTitle;
  year?: GetMangaDraftsOrderYear;
  createdAt?: GetMangaDraftsOrderCreatedAt;
  updatedAt?: GetMangaDraftsOrderUpdatedAt;
};
'includes[]'?: ReferenceExpansionManga;
};

export type GetMangaDraftsState = typeof GetMangaDraftsState[keyof typeof GetMangaDraftsState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaDraftsState = {
  draft: 'draft',
  submitted: 'submitted',
  rejected: 'rejected',
} as const;

export type GetMangaDraftsOrderTitle = typeof GetMangaDraftsOrderTitle[keyof typeof GetMangaDraftsOrderTitle];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaDraftsOrderTitle = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetMangaDraftsOrderYear = typeof GetMangaDraftsOrderYear[keyof typeof GetMangaDraftsOrderYear];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaDraftsOrderYear = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetMangaDraftsOrderCreatedAt = typeof GetMangaDraftsOrderCreatedAt[keyof typeof GetMangaDraftsOrderCreatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaDraftsOrderCreatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetMangaDraftsOrderUpdatedAt = typeof GetMangaDraftsOrderUpdatedAt[keyof typeof GetMangaDraftsOrderUpdatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMangaDraftsOrderUpdatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type PostCaptchaSolveBody = {
  /** @minLength 1 */
  captchaChallenge: string;
};

export type PostCaptchaSolve200Result = typeof PostCaptchaSolve200Result[keyof typeof PostCaptchaSolve200Result];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostCaptchaSolve200Result = {
  ok: 'ok',
  error: 'error',
} as const;

export type PostCaptchaSolve200 = {
  result?: PostCaptchaSolve200Result;
};

export type GetReportReasonsByCategory200DataItemAttributesCategory = typeof GetReportReasonsByCategory200DataItemAttributesCategory[keyof typeof GetReportReasonsByCategory200DataItemAttributesCategory];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReportReasonsByCategory200DataItemAttributesCategory = {
  manga: 'manga',
  chapter: 'chapter',
  scanlation_group: 'scanlation_group',
  user: 'user',
  author: 'author',
} as const;

export type GetReportReasonsByCategory200DataItemAttributes = {
  reason?: LocalizedString;
  detailsRequired?: boolean;
  category?: GetReportReasonsByCategory200DataItemAttributesCategory;
  /** @minimum 1 */
  version?: number;
};

export type GetReportReasonsByCategory200DataItem = {
  id?: string;
  type?: string;
  attributes?: GetReportReasonsByCategory200DataItemAttributes;
};

export type GetReportReasonsByCategory200 = {
  result?: string;
  response?: string;
  data?: GetReportReasonsByCategory200DataItem[];
  limit?: number;
  offset?: number;
  total?: number;
};

export type GetReportsParams = {
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
category?: GetReportsCategory;
/**
 * @minLength 36
 * @maxLength 36
 */
reasonId?: string;
/**
 * @minLength 36
 * @maxLength 36
 */
objectId?: string;
status?: GetReportsStatus;
order?: {
  createdAt?: GetReportsOrderCreatedAt;
};
'includes[]'?: ReferenceExpansionReport;
};

export type GetReportsCategory = typeof GetReportsCategory[keyof typeof GetReportsCategory];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReportsCategory = {
  manga: 'manga',
  chapter: 'chapter',
  scanlation_group: 'scanlation_group',
  user: 'user',
  author: 'author',
} as const;

export type GetReportsStatus = typeof GetReportsStatus[keyof typeof GetReportsStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReportsStatus = {
  waiting: 'waiting',
  accepted: 'accepted',
  refused: 'refused',
  autoresolved: 'autoresolved',
} as const;

export type GetReportsOrderCreatedAt = typeof GetReportsOrderCreatedAt[keyof typeof GetReportsOrderCreatedAt];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReportsOrderCreatedAt = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type PostReportBodyCategory = typeof PostReportBodyCategory[keyof typeof PostReportBodyCategory];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostReportBodyCategory = {
  manga: 'manga',
  chapter: 'chapter',
  user: 'user',
  scanlation_group: 'scanlation_group',
  author: 'author',
} as const;

export type PostReportBody = {
  category?: PostReportBodyCategory;
  /**
   * @minLength 36
   * @maxLength 36
   */
  reason?: string;
  /**
   * @minLength 36
   * @maxLength 36
   */
  objectId?: string;
  details?: string;
};

export type PutUploadSessionFileBody = {
  file?: Blob;
};

export type PutUploadSessionFile200Result = typeof PutUploadSessionFile200Result[keyof typeof PutUploadSessionFile200Result];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PutUploadSessionFile200Result = {
  ok: 'ok',
  error: 'error',
} as const;

export type PutUploadSessionFile200 = {
  result?: PutUploadSessionFile200Result;
  errors?: Error[];
  data?: UploadSessionFile[];
};

export type UploadCheckApprovalRequiredBody = {
  manga?: string;
  /** @pattern ^[a-z]{2}(-[a-z]{2})?$ */
  locale?: string;
};

export type UploadCheckApprovalRequired200AllOf = {
  requiresApproval?: boolean;
};

export type UploadCheckApprovalRequired200 = Response & UploadCheckApprovalRequired200AllOf;

export type GetMangaRelationParams = {
'includes[]'?: ReferenceExpansionMangaRelation;
};

export type GetRatingParams = {
manga: string[];
};

export type GetRating200Ratings = {[key: string]: {
  rating?: number;
  createdAt?: string;
}};

export type GetRating200 = {
  result?: string;
  ratings?: GetRating200Ratings;
};

export type PostRatingMangaIdBody = {
  /**
   * @minimum 1
   * @maximum 10
   */
  rating?: number;
};

export type GetStatisticsChapterUuid200Statistics = {[key: string]: {
  comments?: StatisticsDetailsComments;
}};

export type GetStatisticsChapterUuid200 = {
  result?: string;
  statistics?: GetStatisticsChapterUuid200Statistics;
};

export type GetStatisticsChaptersParams = {
'chapter[]': string[];
};

export type GetStatisticsChapters200Statistics = {[key: string]: {
  comments?: StatisticsDetailsComments;
}};

export type GetStatisticsChapters200 = {
  result?: string;
  statistics?: GetStatisticsChapters200Statistics;
};

export type GetStatisticsGroupUuid200Statistics = {[key: string]: {
  comments?: StatisticsDetailsComments;
}};

export type GetStatisticsGroupUuid200 = {
  result?: string;
  statistics?: GetStatisticsGroupUuid200Statistics;
};

export type GetStatisticsGroupsParams = {
'group[]': string[];
};

export type GetStatisticsGroups200Statistics = {[key: string]: {
  comments?: StatisticsDetailsComments;
}};

export type GetStatisticsGroups200 = {
  result?: string;
  statistics?: GetStatisticsGroups200Statistics;
};

export type GetStatisticsMangaUuid200StatisticsRatingDistribution = {
  '1'?: number;
  '2'?: number;
  '3'?: number;
  '4'?: number;
  '5'?: number;
  '6'?: number;
  '7'?: number;
  '8'?: number;
  '9'?: number;
  '10'?: number;
};

export type GetStatisticsMangaUuid200StatisticsRating = {
  /**
   * Will be nullable if no ratings has been given
   * @nullable
   */
  average?: number | null;
  /**
   * Average weighted on all the Manga population
   */
  bayesian?: number;
  distribution?: GetStatisticsMangaUuid200StatisticsRatingDistribution;
};

export type GetStatisticsMangaUuid200Statistics = {[key: string]: {
  comments?: StatisticsDetailsComments;
  rating?: GetStatisticsMangaUuid200StatisticsRating;
  follows?: number;
  unavailableChapterCount?: number;
}};

export type GetStatisticsMangaUuid200 = {
  result?: string;
  statistics?: GetStatisticsMangaUuid200Statistics;
};

export type GetStatisticsMangaParams = {
'manga[]': string[];
};

export type GetStatisticsManga200StatisticsRating = {
  /**
   * Will be nullable if no ratings has been done
   * @nullable
   */
  average?: number | null;
  /**
   * Average weighted on all the Manga population
   */
  bayesian?: number;
};

export type GetStatisticsManga200Statistics = {[key: string]: {
  comments?: StatisticsDetailsComments;
  rating?: GetStatisticsManga200StatisticsRating;
  follows?: number;
}};

export type GetStatisticsManga200 = {
  result?: string;
  statistics?: GetStatisticsManga200Statistics;
};

/**
 * JSON Schema to validate settings
 */
export type GetSettingsTemplate200 = { [key: string]: unknown };

/**
 * A JSON Schema to validate settings
 */
export type PostSettingsTemplateBody = { [key: string]: unknown };

/**
 * JSON Schema to validate settings
 */
export type PostSettingsTemplate200 = { [key: string]: unknown };

/**
 * JSON Schema to validate settings
 */
export type GetSettingsTemplateVersion200 = { [key: string]: unknown };

/**
 * Settings that were validated by linked template
 */
export type GetSettings200Settings = { [key: string]: unknown };

export type GetSettings200 = {
  result?: string;
  updatedAt?: string;
  /** Settings that were validated by linked template */
  settings?: GetSettings200Settings;
  /** Settings template UUID */
  template?: string;
};

/**
 * A JSON object that can be validated against the lastest available template
 */
export type PostSettingsBodySettings = { [key: string]: unknown };

export type PostSettingsBody = {
  /** A JSON object that can be validated against the lastest available template */
  settings?: PostSettingsBodySettings;
  /** Format: 2022-03-14T13:19:37 */
  updatedAt?: string;
};

/**
 * Settings that were validated against the linked template
 */
export type PostSettings200Settings = { [key: string]: unknown };

export type PostSettings200 = {
  result?: string;
  updatedAt?: string;
  /** Settings that were validated against the linked template */
  settings?: PostSettings200Settings;
  /** Settings template UUID */
  template?: string;
};

export type GetReadingHistory200RatingsItem = {
  chapterId?: string;
  readDate?: string;
};

export type GetReadingHistory200 = {
  result?: string;
  ratings?: GetReadingHistory200RatingsItem[];
};

/**
 * The type of the resource
 */
export type ForumsThreadCreateBodyType = typeof ForumsThreadCreateBodyType[keyof typeof ForumsThreadCreateBodyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ForumsThreadCreateBodyType = {
  manga: 'manga',
  group: 'group',
  chapter: 'chapter',
} as const;

export type ForumsThreadCreateBody = {
  /** The type of the resource */
  type?: ForumsThreadCreateBodyType;
  /** The id of the resource */
  id?: string;
};

/**
 * Returns a plaintext response containing only the word "pong" if the API is healthy
 * @summary Ping healthcheck
 */
export const getPing = (
    
 ) => {
      return axiosFetch<string>(
      {url: `/ping`, method: 'GET'
    },
      );
    }
  
/**
 * Search a list of Manga.
 * @summary Manga list
 */
export const getSearchManga = (
    params?: GetSearchMangaParams,
 ) => {
      return axiosFetch<MangaList>(
      {url: `/manga`, method: 'GET',
        params
    },
      );
    }
  
/**
 * Create a new Manga.
 * @summary Create Manga
 */
export const postManga = (
    mangaCreate: MangaCreate,
 ) => {
      return axiosFetch<MangaResponse>(
      {url: `/manga`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mangaCreate
    },
      );
    }
  
/**
 * @summary Get Manga volumes & chapters
 */
export const getMangaAggregate = (
    id: string,
    params?: GetMangaAggregateParams,
 ) => {
      return axiosFetch<GetMangaAggregate200>(
      {url: `/manga/${id}/aggregate`, method: 'GET',
        params
    },
      );
    }
  
/**
 * Get Manga.
 * @summary Get Manga
 */
export const getMangaId = (
    id: string,
    params?: GetMangaIdParams,
 ) => {
      return axiosFetch<MangaResponse>(
      {url: `/manga/${id}`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Update Manga
 */
export const putMangaId = (
    id: string,
    putMangaIdBody: PutMangaIdBody,
 ) => {
      return axiosFetch<MangaResponse>(
      {url: `/manga/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putMangaIdBody
    },
      );
    }
  
/**
 * @summary Delete Manga
 */
export const deleteMangaId = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/manga/${id}`, method: 'DELETE'
    },
      );
    }
  
/**
 * @deprecated
 * @summary Login
 */
export const postAuthLogin = (
    login: Login,
 ) => {
      return axiosFetch<LoginResponse>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: login
    },
      );
    }
  
/**
 * The returned list of permissions is computed depending on the generic role permissions that the token user has, their personal overrides, and the OpenID scopes of the token (we do not offer granular token permissions yet)

 * @summary Check the set of permissions associated with the current token
 */
export const getAuthCheck = (
    
 ) => {
      return axiosFetch<CheckResponse>(
      {url: `/auth/check`, method: 'GET'
    },
      );
    }
  
/**
 * @deprecated
 * @summary Logout
 */
export const postAuthLogout = (
    
 ) => {
      return axiosFetch<LogoutResponse>(
      {url: `/auth/logout`, method: 'POST'
    },
      );
    }
  
/**
 * @deprecated
 * @summary Refresh token
 */
export const postAuthRefresh = (
    refreshToken: RefreshToken,
 ) => {
      return axiosFetch<RefreshResponse>(
      {url: `/auth/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshToken
    },
      );
    }
  
/**
 * @summary List own Api Clients
 */
export const getListApiclients = (
    params?: GetListApiclientsParams,
 ) => {
      return axiosFetch<ApiClientList>(
      {url: `/client`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Create ApiClient
 */
export const postCreateApiclient = (
    apiClientCreate: ApiClientCreate,
 ) => {
      return axiosFetch<ApiClientResponse>(
      {url: `/client`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: apiClientCreate
    },
      );
    }
  
/**
 * @summary Get Api Client by ID
 */
export const getApiclient = (
    id: string,
    params?: GetApiclientParams,
 ) => {
      return axiosFetch<ApiClientResponse>(
      {url: `/client/${id}`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Edit ApiClient
 */
export const postEditApiclient = (
    id: string,
    apiClientEdit: ApiClientEdit,
 ) => {
      return axiosFetch<ApiClientResponse>(
      {url: `/client/${id}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: apiClientEdit
    },
      );
    }
  
/**
 * @summary Delete Api Client
 */
export const deleteApiclient = (
    id: string,
    params?: DeleteApiclientParams,
 ) => {
      return axiosFetch<DeleteApiclient200>(
      {url: `/client/${id}`, method: 'DELETE',
        params
    },
      );
    }
  
/**
 * @summary Get Secret for Client by ID
 */
export const getApiclientSecret = (
    id: string,
 ) => {
      return axiosFetch<GetApiclientSecret200>(
      {url: `/client/${id}/secret`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Regenerate Client Secret
 */
export const postRegenerateApiclientSecret = (
    id: string,
    postRegenerateApiclientSecretBody: PostRegenerateApiclientSecretBody,
 ) => {
      return axiosFetch<PostRegenerateApiclientSecret200>(
      {url: `/client/${id}/secret`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postRegenerateApiclientSecretBody
    },
      );
    }
  
/**
 * @summary Scanlation Group list
 */
export const getSearchGroup = (
    params?: GetSearchGroupParams,
 ) => {
      return axiosFetch<ScanlationGroupList>(
      {url: `/group`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Create Scanlation Group
 */
export const postGroup = (
    createScanlationGroup: CreateScanlationGroup,
 ) => {
      return axiosFetch<ScanlationGroupResponse>(
      {url: `/group`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createScanlationGroup
    },
      );
    }
  
/**
 * @summary Get Scanlation Group
 */
export const getGroupId = (
    id: string,
    params?: GetGroupIdParams,
 ) => {
      return axiosFetch<ScanlationGroupResponse>(
      {url: `/group/${id}`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Update Scanlation Group
 */
export const putGroupId = (
    id: string,
    scanlationGroupEdit: ScanlationGroupEdit,
 ) => {
      return axiosFetch<ScanlationGroupResponse>(
      {url: `/group/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: scanlationGroupEdit
    },
      );
    }
  
/**
 * @summary Delete Scanlation Group
 */
export const deleteGroupId = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/group/${id}`, method: 'DELETE'
    },
      );
    }
  
/**
 * @summary Follow Scanlation Group
 */
export const postGroupIdFollow = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/group/${id}/follow`, method: 'POST'
    },
      );
    }
  
/**
 * @summary Unfollow Scanlation Group
 */
export const deleteGroupIdFollow = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/group/${id}/follow`, method: 'DELETE'
    },
      );
    }
  
/**
 * @summary Create CustomList
 */
export const postList = (
    customListCreate: CustomListCreate,
 ) => {
      return axiosFetch<CustomListResponse>(
      {url: `/list`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: customListCreate
    },
      );
    }
  
/**
 * @summary Get CustomList
 */
export const getListId = (
    id: string,
 ) => {
      return axiosFetch<CustomListResponse>(
      {url: `/list/${id}`, method: 'GET'
    },
      );
    }
  
/**
 * The size of the body is limited to 8KB.
 * @summary Update CustomList
 */
export const putListId = (
    id: string,
    customListEdit: CustomListEdit,
 ) => {
      return axiosFetch<CustomListResponse>(
      {url: `/list/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: customListEdit
    },
      );
    }
  
/**
 * @summary Delete CustomList
 */
export const deleteListId = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/list/${id}`, method: 'DELETE'
    },
      );
    }
  
/**
 * The request body is empty
 * @summary Follow CustomList
 */
export const followListId = (
    id: string,
    followListIdBody: FollowListIdBody,
 ) => {
      return axiosFetch<FollowListId200>(
      {url: `/list/${id}/follow`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: followListIdBody
    },
      );
    }
  
/**
 * The request body is empty
 * @summary Unfollow CustomList
 */
export const unfollowListId = (
    id: string,
    unfollowListIdBody: UnfollowListIdBody,
 ) => {
      return axiosFetch<UnfollowListId200>(
      {url: `/list/${id}/follow`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: unfollowListIdBody
    },
      );
    }
  
/**
 * @summary Add Manga in CustomList
 */
export const postMangaIdListListId = (
    id: string,
    listId: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/manga/${id}/list/${listId}`, method: 'POST'
    },
      );
    }
  
/**
 * @summary Remove Manga in CustomList
 */
export const deleteMangaIdListListId = (
    id: string,
    listId: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/manga/${id}/list/${listId}`, method: 'DELETE'
    },
      );
    }
  
/**
 * This will list public and private CustomList
 * @summary Get logged User CustomList list
 */
export const getUserList = (
    params?: GetUserListParams,
 ) => {
      return axiosFetch<CustomListList>(
      {url: `/user/list`, method: 'GET',
        params
    },
      );
    }
  
/**
 * This will list only public CustomList
 * @summary Get User's CustomList list
 */
export const getUserIdList = (
    id: string,
    params?: GetUserIdListParams,
 ) => {
      return axiosFetch<CustomListList>(
      {url: `/user/${id}/list`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary User list
 */
export const getUser = (
    params?: GetUserParams,
 ) => {
      return axiosFetch<UserList>(
      {url: `/user`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Get User
 */
export const getUserId = (
    id: string,
 ) => {
      return axiosFetch<UserResponse>(
      {url: `/user/${id}`, method: 'GET'
    },
      );
    }
  
/**
 * @deprecated
 * @summary Delete User
 */
export const deleteUserId = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/user/${id}`, method: 'DELETE'
    },
      );
    }
  
/**
 * @deprecated
 * @summary Approve User deletion
 */
export const postUserDeleteCode = (
    code: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/user/delete/${code}`, method: 'POST'
    },
      );
    }
  
/**
 * Chapter list. If you want the Chapters of a given Manga, please check the feed endpoints.
 * @summary Chapter list
 */
export const getChapter = (
    params?: GetChapterParams,
 ) => {
      return axiosFetch<ChapterList>(
      {url: `/chapter`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Get Chapter
 */
export const getChapterId = (
    id: string,
    params?: GetChapterIdParams,
 ) => {
      return axiosFetch<ChapterResponse>(
      {url: `/chapter/${id}`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Update Chapter
 */
export const putChapterId = (
    id: string,
    chapterEdit: ChapterEdit,
 ) => {
      return axiosFetch<ChapterResponse>(
      {url: `/chapter/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: chapterEdit
    },
      );
    }
  
/**
 * @summary Delete Chapter
 */
export const deleteChapterId = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/chapter/${id}`, method: 'DELETE'
    },
      );
    }
  
/**
 * @summary Get logged User followed Manga feed (Chapter list)
 */
export const getUserFollowsMangaFeed = (
    params?: GetUserFollowsMangaFeedParams,
 ) => {
      return axiosFetch<ChapterList>(
      {url: `/user/follows/manga/feed`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary CustomList Manga feed
 */
export const getListIdFeed = (
    id: string,
    params?: GetListIdFeedParams,
 ) => {
      return axiosFetch<ChapterList>(
      {url: `/list/${id}/feed`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Unfollow Manga
 */
export const deleteMangaIdFollow = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/manga/${id}/follow`, method: 'DELETE'
    },
      );
    }
  
/**
 * @summary Follow Manga
 */
export const postMangaIdFollow = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/manga/${id}/follow`, method: 'POST'
    },
      );
    }
  
/**
 * @summary CoverArt list
 */
export const getCover = (
    params?: GetCoverParams,
 ) => {
      return axiosFetch<CoverList>(
      {url: `/cover`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Upload Cover
 */
export const uploadCover = (
    mangaOrCoverId: string,
    uploadCoverBody: UploadCoverBody,
 ) => {const formData = new FormData();
if(uploadCoverBody.file !== undefined) {
 formData.append(`file`, uploadCoverBody.file)
 }
if(uploadCoverBody.volume !== undefined && uploadCoverBody.volume !== null) {
 formData.append(`volume`, uploadCoverBody.volume)
 }
if(uploadCoverBody.description !== undefined) {
 formData.append(`description`, uploadCoverBody.description)
 }
if(uploadCoverBody.locale !== undefined) {
 formData.append(`locale`, uploadCoverBody.locale)
 }

      return axiosFetch<CoverResponse>(
      {url: `/cover/${mangaOrCoverId}`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData
    },
      );
    }
  
/**
 * @summary Get Cover
 */
export const getCoverId = (
    mangaOrCoverId: string,
    params?: GetCoverIdParams,
 ) => {
      return axiosFetch<CoverResponse>(
      {url: `/cover/${mangaOrCoverId}`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Edit Cover
 */
export const editCover = (
    mangaOrCoverId: string,
    coverEdit: CoverEdit,
 ) => {
      return axiosFetch<CoverResponse>(
      {url: `/cover/${mangaOrCoverId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: coverEdit
    },
      );
    }
  
/**
 * @summary Delete Cover
 */
export const deleteCover = (
    mangaOrCoverId: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/cover/${mangaOrCoverId}`, method: 'DELETE'
    },
      );
    }
  
/**
 * @summary Author list
 */
export const getAuthor = (
    params?: GetAuthorParams,
 ) => {
      return axiosFetch<AuthorList>(
      {url: `/author`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Create Author
 */
export const postAuthor = (
    authorCreate: AuthorCreate,
 ) => {
      return axiosFetch<AuthorResponse>(
      {url: `/author`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: authorCreate
    },
      );
    }
  
/**
 * @summary Get Author
 */
export const getAuthorId = (
    id: string,
    params?: GetAuthorIdParams,
 ) => {
      return axiosFetch<AuthorResponse>(
      {url: `/author/${id}`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Update Author
 */
export const putAuthorId = (
    id: string,
    authorEdit: AuthorEdit,
 ) => {
      return axiosFetch<AuthorResponse>(
      {url: `/author/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: authorEdit
    },
      );
    }
  
/**
 * @summary Delete Author
 */
export const deleteAuthorId = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/author/${id}`, method: 'DELETE'
    },
      );
    }
  
/**
 * @summary Legacy ID mapping
 */
export const postLegacyMapping = (
    mappingIdBody: MappingIdBody,
 ) => {
      return axiosFetch<MappingIdResponse>(
      {url: `/legacy/mapping`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mappingIdBody
    },
      );
    }
  
/**
 * @summary Manga feed
 */
export const getMangaIdFeed = (
    id: string,
    params?: GetMangaIdFeedParams,
 ) => {
      return axiosFetch<ChapterList>(
      {url: `/manga/${id}/feed`, method: 'GET',
        params
    },
      );
    }
  
/**
 * A list of chapter ids that are marked as read for the specified manga
 * @summary Manga read markers
 */
export const getMangaChapterReadmarkers = (
    id: string,
 ) => {
      return axiosFetch<GetMangaChapterReadmarkers200>(
      {url: `/manga/${id}/read`, method: 'GET'
    },
      );
    }
  
/**
 * Send a lot of chapter ids for one manga to mark as read and/or unread
 * @summary Manga read markers batch
 */
export const postMangaChapterReadmarkers = (
    id: string,
    chapterReadMarkerBatch: ChapterReadMarkerBatch,
    params?: PostMangaChapterReadmarkersParams,
 ) => {
      return axiosFetch<PostMangaChapterReadmarkers200>(
      {url: `/manga/${id}/read`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: chapterReadMarkerBatch,
        params
    },
      );
    }
  
/**
 * A list of chapter ids that are marked as read for the given manga ids
 * @summary Manga read markers
 */
export const getMangaChapterReadmarkers2 = (
    params: GetMangaChapterReadmarkers2Params,
 ) => {
      return axiosFetch<GetMangaChapterReadmarkers2200>(
      {url: `/manga/read`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Get a random Manga
 */
export const getMangaRandom = (
    params?: GetMangaRandomParams,
 ) => {
      return axiosFetch<MangaResponse>(
      {url: `/manga/random`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Get MangaDex@Home server URL
 */
export const getAtHomeServerChapterId = (
    chapterId: string,
    params?: GetAtHomeServerChapterIdParams,
 ) => {
      return axiosFetch<GetAtHomeServerChapterId200>(
      {url: `/at-home/server/${chapterId}`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Tag list
 */
export const getMangaTag = (
    
 ) => {
      return axiosFetch<TagResponse>(
      {url: `/manga/tag`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Logged User details
 */
export const getUserMe = (
    
 ) => {
      return axiosFetch<UserResponse>(
      {url: `/user/me`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Get logged User followed Groups
 */
export const getUserFollowsGroup = (
    params?: GetUserFollowsGroupParams,
 ) => {
      return axiosFetch<ScanlationGroupList>(
      {url: `/user/follows/group`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Check if logged User follows a Group
 */
export const getUserFollowsGroupId = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/user/follows/group/${id}`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Get logged User followed User list
 */
export const getUserFollowsUser = (
    params?: GetUserFollowsUserParams,
 ) => {
      return axiosFetch<UserList>(
      {url: `/user/follows/user`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Check if logged User follows a User
 */
export const getUserFollowsUserId = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/user/follows/user/${id}`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Get logged User followed Manga list
 */
export const getUserFollowsManga = (
    params?: GetUserFollowsMangaParams,
 ) => {
      return axiosFetch<MangaList>(
      {url: `/user/follows/manga`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Check if logged User follows a Manga
 */
export const getUserFollowsMangaId = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/user/follows/manga/${id}`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Get logged User followed CustomList list
 */
export const getUserFollowsList = (
    params?: GetUserFollowsListParams,
 ) => {
      return axiosFetch<CustomListList>(
      {url: `/user/follows/list`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Check if logged User follows a CustomList
 */
export const getUserFollowsListId = (
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/user/follows/list/${id}`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Get all Manga reading status for logged User
 */
export const getMangaStatus = (
    params?: GetMangaStatusParams,
 ) => {
      return axiosFetch<GetMangaStatus200>(
      {url: `/manga/status`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Get a Manga reading status
 */
export const getMangaIdStatus = (
    id: string,
 ) => {
      return axiosFetch<GetMangaIdStatus200>(
      {url: `/manga/${id}/status`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Update Manga reading status
 */
export const postMangaIdStatus = (
    id: string,
    updateMangaStatus: UpdateMangaStatus,
 ) => {
      return axiosFetch<Response>(
      {url: `/manga/${id}/status`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: updateMangaStatus
    },
      );
    }
  
/**
 * @summary Get a specific Manga Draft
 */
export const getMangaIdDraft = (
    id: string,
    params?: GetMangaIdDraftParams,
 ) => {
      return axiosFetch<MangaResponse>(
      {url: `/manga/draft/${id}`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Submit a Manga Draft
 */
export const commitMangaDraft = (
    id: string,
    commitMangaDraftBody: CommitMangaDraftBody,
 ) => {
      return axiosFetch<MangaResponse>(
      {url: `/manga/draft/${id}/commit`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: commitMangaDraftBody
    },
      );
    }
  
/**
 * @summary Get a list of Manga Drafts
 */
export const getMangaDrafts = (
    params?: GetMangaDraftsParams,
 ) => {
      return axiosFetch<MangaResponse>(
      {url: `/manga/draft`, method: 'GET',
        params
    },
      );
    }
  
/**
 * Captchas can be solved explicitly through this endpoint, another way is to add a `X-Captcha-Result` header to any request. The same logic will verify the captcha and is probably more convenient because it takes one less request.

Authentication is optional. Captchas are tracked for both the client ip and for the user id, if you are logged in you want to send your session token but that is not required.
 * @summary Solve Captcha
 */
export const postCaptchaSolve = (
    postCaptchaSolveBody: PostCaptchaSolveBody,
 ) => {
      return axiosFetch<PostCaptchaSolve200>(
      {url: `/captcha/solve`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postCaptchaSolveBody
    },
      );
    }
  
/**
 * @summary Get a list of report reasons
 */
export const getReportReasonsByCategory = (
    category: 'manga' | 'chapter' | 'scanlation_group' | 'user' | 'author',
 ) => {
      return axiosFetch<GetReportReasonsByCategory200>(
      {url: `/report/reasons/${category}`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Get a list of reports by the user
 */
export const getReports = (
    params?: GetReportsParams,
 ) => {
      return axiosFetch<ReportListResponse>(
      {url: `/report`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Create a new Report
 */
export const postReport = (
    postReportBody: PostReportBody,
 ) => {
      return axiosFetch<Response>(
      {url: `/report`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postReportBody
    },
      );
    }
  
/**
 * @summary Get the current User upload session
 */
export const getUploadSession = (
    
 ) => {
      return axiosFetch<UploadSession>(
      {url: `/upload`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Start an upload session
 */
export const beginUploadSession = (
    beginUploadSession: BeginUploadSession,
 ) => {
      return axiosFetch<UploadSession>(
      {url: `/upload/begin`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: beginUploadSession
    },
      );
    }
  
/**
 * @summary Start an edit chapter session
 */
export const beginEditSession = (
    chapterId: string,
    beginEditSession: BeginEditSession,
 ) => {
      return axiosFetch<UploadSession>(
      {url: `/upload/begin/${chapterId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: beginEditSession
    },
      );
    }
  
/**
 * @summary Upload images to the upload session
 */
export const putUploadSessionFile = (
    uploadSessionId: string,
    putUploadSessionFileBody: PutUploadSessionFileBody,
 ) => {const formData = new FormData();
if(putUploadSessionFileBody.file !== undefined) {
 formData.append(`file`, putUploadSessionFileBody.file)
 }

      return axiosFetch<PutUploadSessionFile200>(
      {url: `/upload/${uploadSessionId}`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData
    },
      );
    }
  
/**
 * @summary Abandon upload session
 */
export const abandonUploadSession = (
    uploadSessionId: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/upload/${uploadSessionId}`, method: 'DELETE'
    },
      );
    }
  
/**
 * @summary Commit the upload session and specify chapter data
 */
export const commitUploadSession = (
    uploadSessionId: string,
    commitUploadSession: CommitUploadSession,
 ) => {
      return axiosFetch<Chapter>(
      {url: `/upload/${uploadSessionId}/commit`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: commitUploadSession
    },
      );
    }
  
/**
 * @summary Delete an uploaded image from the Upload Session
 */
export const deleteUploadedSessionFile = (
    uploadSessionId: string,
    uploadSessionFileId: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/upload/${uploadSessionId}/${uploadSessionFileId}`, method: 'DELETE'
    },
      );
    }
  
/**
 * @summary Delete a set of uploaded images from the Upload Session
 */
export const deleteUploadedSessionFiles = (
    uploadSessionId: string,
    deleteUploadedSessionFilesBody: string[],
 ) => {
      return axiosFetch<Response>(
      {url: `/upload/${uploadSessionId}/batch`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deleteUploadedSessionFilesBody
    },
      );
    }
  
/**
 * @summary Check if a given manga / locale for a User needs moderation approval
 */
export const uploadCheckApprovalRequired = (
    uploadCheckApprovalRequiredBody: UploadCheckApprovalRequiredBody,
 ) => {
      return axiosFetch<UploadCheckApprovalRequired200>(
      {url: `/upload/check-approval-required`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: uploadCheckApprovalRequiredBody
    },
      );
    }
  
/**
 * @summary Manga relation list
 */
export const getMangaRelation = (
    mangaId: string,
    params?: GetMangaRelationParams,
 ) => {
      return axiosFetch<MangaRelationList>(
      {url: `/manga/${mangaId}/relation`, method: 'GET',
        params
    },
      );
    }
  
/**
 * Create a new Manga relation.
 * @summary Create Manga relation
 */
export const postMangaRelation = (
    mangaId: string,
    mangaRelationCreate: MangaRelationCreate,
 ) => {
      return axiosFetch<MangaRelationResponse>(
      {url: `/manga/${mangaId}/relation`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mangaRelationCreate
    },
      );
    }
  
/**
 * @summary Delete Manga relation
 */
export const deleteMangaRelationId = (
    mangaId: string,
    id: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/manga/${mangaId}/relation/${id}`, method: 'DELETE'
    },
      );
    }
  
/**
 * @summary Get your ratings
 */
export const getRating = (
    params: GetRatingParams,
 ) => {
      return axiosFetch<GetRating200>(
      {url: `/rating`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Create or update Manga rating
 */
export const postRatingMangaId = (
    mangaId: string,
    postRatingMangaIdBody: PostRatingMangaIdBody,
 ) => {
      return axiosFetch<Response>(
      {url: `/rating/${mangaId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postRatingMangaIdBody
    },
      );
    }
  
/**
 * @summary Delete Manga rating
 */
export const deleteRatingMangaId = (
    mangaId: string,
 ) => {
      return axiosFetch<Response>(
      {url: `/rating/${mangaId}`, method: 'DELETE'
    },
      );
    }
  
/**
 * @summary Get statistics about given chapter
 */
export const getStatisticsChapterUuid = (
    uuid: string,
 ) => {
      return axiosFetch<GetStatisticsChapterUuid200>(
      {url: `/statistics/chapter/${uuid}`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Get statistics about given chapters
 */
export const getStatisticsChapters = (
    params: GetStatisticsChaptersParams,
 ) => {
      return axiosFetch<GetStatisticsChapters200>(
      {url: `/statistics/chapter`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Get statistics about given scanlation group
 */
export const getStatisticsGroupUuid = (
    uuid: string,
 ) => {
      return axiosFetch<GetStatisticsGroupUuid200>(
      {url: `/statistics/group/${uuid}`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Get statistics about given groups
 */
export const getStatisticsGroups = (
    params: GetStatisticsGroupsParams,
 ) => {
      return axiosFetch<GetStatisticsGroups200>(
      {url: `/statistics/group`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Get statistics about given Manga
 */
export const getStatisticsMangaUuid = (
    uuid: string,
 ) => {
      return axiosFetch<GetStatisticsMangaUuid200>(
      {url: `/statistics/manga/${uuid}`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Find statistics about given Manga
 */
export const getStatisticsManga = (
    params: GetStatisticsMangaParams,
 ) => {
      return axiosFetch<GetStatisticsManga200>(
      {url: `/statistics/manga`, method: 'GET',
        params
    },
      );
    }
  
/**
 * @summary Get latest Settings template
 */
export const getSettingsTemplate = (
    
 ) => {
      return axiosFetch<GetSettingsTemplate200>(
      {url: `/settings/template`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Create Settings template
 */
export const postSettingsTemplate = (
    postSettingsTemplateBody: PostSettingsTemplateBody,
 ) => {
      return axiosFetch<PostSettingsTemplate200>(
      {url: `/settings/template`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postSettingsTemplateBody
    },
      );
    }
  
/**
 * @summary Get Settings template by version id
 */
export const getSettingsTemplateVersion = (
    version: string,
 ) => {
      return axiosFetch<GetSettingsTemplateVersion200>(
      {url: `/settings/template/${version}`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Get an User Settings
 */
export const getSettings = (
    
 ) => {
      return axiosFetch<GetSettings200>(
      {url: `/settings`, method: 'GET'
    },
      );
    }
  
/**
 * @summary Create or update an User Settings
 */
export const postSettings = (
    postSettingsBody: PostSettingsBody,
 ) => {
      return axiosFetch<PostSettings200>(
      {url: `/settings`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postSettingsBody
    },
      );
    }
  
/**
 * @summary Get users reading history
 */
export const getReadingHistory = (
    
 ) => {
      return axiosFetch<GetReadingHistory200>(
      {url: `/user/history`, method: 'GET'
    },
      );
    }
  
/**
 * Creates a thread in the forums for the given resource, which backs the comments functionality.
A thread is only created if it doesn't exist yet; otherwise the preexisting thread is returned.

 * @summary Create forums thread
 */
export const forumsThreadCreate = (
    forumsThreadCreateBody: ForumsThreadCreateBody,
 ) => {
      return axiosFetch<ForumsThreadResponse>(
      {url: `/forums/thread`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: forumsThreadCreateBody
    },
      );
    }
  
export type GetPingResult = NonNullable<Awaited<ReturnType<typeof getPing>>>
export type GetSearchMangaResult = NonNullable<Awaited<ReturnType<typeof getSearchManga>>>
export type PostMangaResult = NonNullable<Awaited<ReturnType<typeof postManga>>>
export type GetMangaAggregateResult = NonNullable<Awaited<ReturnType<typeof getMangaAggregate>>>
export type GetMangaIdResult = NonNullable<Awaited<ReturnType<typeof getMangaId>>>
export type PutMangaIdResult = NonNullable<Awaited<ReturnType<typeof putMangaId>>>
export type DeleteMangaIdResult = NonNullable<Awaited<ReturnType<typeof deleteMangaId>>>
export type PostAuthLoginResult = NonNullable<Awaited<ReturnType<typeof postAuthLogin>>>
export type GetAuthCheckResult = NonNullable<Awaited<ReturnType<typeof getAuthCheck>>>
export type PostAuthLogoutResult = NonNullable<Awaited<ReturnType<typeof postAuthLogout>>>
export type PostAuthRefreshResult = NonNullable<Awaited<ReturnType<typeof postAuthRefresh>>>
export type GetListApiclientsResult = NonNullable<Awaited<ReturnType<typeof getListApiclients>>>
export type PostCreateApiclientResult = NonNullable<Awaited<ReturnType<typeof postCreateApiclient>>>
export type GetApiclientResult = NonNullable<Awaited<ReturnType<typeof getApiclient>>>
export type PostEditApiclientResult = NonNullable<Awaited<ReturnType<typeof postEditApiclient>>>
export type DeleteApiclientResult = NonNullable<Awaited<ReturnType<typeof deleteApiclient>>>
export type GetApiclientSecretResult = NonNullable<Awaited<ReturnType<typeof getApiclientSecret>>>
export type PostRegenerateApiclientSecretResult = NonNullable<Awaited<ReturnType<typeof postRegenerateApiclientSecret>>>
export type GetSearchGroupResult = NonNullable<Awaited<ReturnType<typeof getSearchGroup>>>
export type PostGroupResult = NonNullable<Awaited<ReturnType<typeof postGroup>>>
export type GetGroupIdResult = NonNullable<Awaited<ReturnType<typeof getGroupId>>>
export type PutGroupIdResult = NonNullable<Awaited<ReturnType<typeof putGroupId>>>
export type DeleteGroupIdResult = NonNullable<Awaited<ReturnType<typeof deleteGroupId>>>
export type PostGroupIdFollowResult = NonNullable<Awaited<ReturnType<typeof postGroupIdFollow>>>
export type DeleteGroupIdFollowResult = NonNullable<Awaited<ReturnType<typeof deleteGroupIdFollow>>>
export type PostListResult = NonNullable<Awaited<ReturnType<typeof postList>>>
export type GetListIdResult = NonNullable<Awaited<ReturnType<typeof getListId>>>
export type PutListIdResult = NonNullable<Awaited<ReturnType<typeof putListId>>>
export type DeleteListIdResult = NonNullable<Awaited<ReturnType<typeof deleteListId>>>
export type FollowListIdResult = NonNullable<Awaited<ReturnType<typeof followListId>>>
export type UnfollowListIdResult = NonNullable<Awaited<ReturnType<typeof unfollowListId>>>
export type PostMangaIdListListIdResult = NonNullable<Awaited<ReturnType<typeof postMangaIdListListId>>>
export type DeleteMangaIdListListIdResult = NonNullable<Awaited<ReturnType<typeof deleteMangaIdListListId>>>
export type GetUserListResult = NonNullable<Awaited<ReturnType<typeof getUserList>>>
export type GetUserIdListResult = NonNullable<Awaited<ReturnType<typeof getUserIdList>>>
export type GetUserResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserIdResult = NonNullable<Awaited<ReturnType<typeof getUserId>>>
export type DeleteUserIdResult = NonNullable<Awaited<ReturnType<typeof deleteUserId>>>
export type PostUserDeleteCodeResult = NonNullable<Awaited<ReturnType<typeof postUserDeleteCode>>>
export type GetChapterResult = NonNullable<Awaited<ReturnType<typeof getChapter>>>
export type GetChapterIdResult = NonNullable<Awaited<ReturnType<typeof getChapterId>>>
export type PutChapterIdResult = NonNullable<Awaited<ReturnType<typeof putChapterId>>>
export type DeleteChapterIdResult = NonNullable<Awaited<ReturnType<typeof deleteChapterId>>>
export type GetUserFollowsMangaFeedResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsMangaFeed>>>
export type GetListIdFeedResult = NonNullable<Awaited<ReturnType<typeof getListIdFeed>>>
export type DeleteMangaIdFollowResult = NonNullable<Awaited<ReturnType<typeof deleteMangaIdFollow>>>
export type PostMangaIdFollowResult = NonNullable<Awaited<ReturnType<typeof postMangaIdFollow>>>
export type GetCoverResult = NonNullable<Awaited<ReturnType<typeof getCover>>>
export type UploadCoverResult = NonNullable<Awaited<ReturnType<typeof uploadCover>>>
export type GetCoverIdResult = NonNullable<Awaited<ReturnType<typeof getCoverId>>>
export type EditCoverResult = NonNullable<Awaited<ReturnType<typeof editCover>>>
export type DeleteCoverResult = NonNullable<Awaited<ReturnType<typeof deleteCover>>>
export type GetAuthorResult = NonNullable<Awaited<ReturnType<typeof getAuthor>>>
export type PostAuthorResult = NonNullable<Awaited<ReturnType<typeof postAuthor>>>
export type GetAuthorIdResult = NonNullable<Awaited<ReturnType<typeof getAuthorId>>>
export type PutAuthorIdResult = NonNullable<Awaited<ReturnType<typeof putAuthorId>>>
export type DeleteAuthorIdResult = NonNullable<Awaited<ReturnType<typeof deleteAuthorId>>>
export type PostLegacyMappingResult = NonNullable<Awaited<ReturnType<typeof postLegacyMapping>>>
export type GetMangaIdFeedResult = NonNullable<Awaited<ReturnType<typeof getMangaIdFeed>>>
export type GetMangaChapterReadmarkersResult = NonNullable<Awaited<ReturnType<typeof getMangaChapterReadmarkers>>>
export type PostMangaChapterReadmarkersResult = NonNullable<Awaited<ReturnType<typeof postMangaChapterReadmarkers>>>
export type GetMangaChapterReadmarkers2Result = NonNullable<Awaited<ReturnType<typeof getMangaChapterReadmarkers2>>>
export type GetMangaRandomResult = NonNullable<Awaited<ReturnType<typeof getMangaRandom>>>
export type GetAtHomeServerChapterIdResult = NonNullable<Awaited<ReturnType<typeof getAtHomeServerChapterId>>>
export type GetMangaTagResult = NonNullable<Awaited<ReturnType<typeof getMangaTag>>>
export type GetUserMeResult = NonNullable<Awaited<ReturnType<typeof getUserMe>>>
export type GetUserFollowsGroupResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsGroup>>>
export type GetUserFollowsGroupIdResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsGroupId>>>
export type GetUserFollowsUserResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsUser>>>
export type GetUserFollowsUserIdResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsUserId>>>
export type GetUserFollowsMangaResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsManga>>>
export type GetUserFollowsMangaIdResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsMangaId>>>
export type GetUserFollowsListResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsList>>>
export type GetUserFollowsListIdResult = NonNullable<Awaited<ReturnType<typeof getUserFollowsListId>>>
export type GetMangaStatusResult = NonNullable<Awaited<ReturnType<typeof getMangaStatus>>>
export type GetMangaIdStatusResult = NonNullable<Awaited<ReturnType<typeof getMangaIdStatus>>>
export type PostMangaIdStatusResult = NonNullable<Awaited<ReturnType<typeof postMangaIdStatus>>>
export type GetMangaIdDraftResult = NonNullable<Awaited<ReturnType<typeof getMangaIdDraft>>>
export type CommitMangaDraftResult = NonNullable<Awaited<ReturnType<typeof commitMangaDraft>>>
export type GetMangaDraftsResult = NonNullable<Awaited<ReturnType<typeof getMangaDrafts>>>
export type PostCaptchaSolveResult = NonNullable<Awaited<ReturnType<typeof postCaptchaSolve>>>
export type GetReportReasonsByCategoryResult = NonNullable<Awaited<ReturnType<typeof getReportReasonsByCategory>>>
export type GetReportsResult = NonNullable<Awaited<ReturnType<typeof getReports>>>
export type PostReportResult = NonNullable<Awaited<ReturnType<typeof postReport>>>
export type GetUploadSessionResult = NonNullable<Awaited<ReturnType<typeof getUploadSession>>>
export type BeginUploadSessionResult = NonNullable<Awaited<ReturnType<typeof beginUploadSession>>>
export type BeginEditSessionResult = NonNullable<Awaited<ReturnType<typeof beginEditSession>>>
export type PutUploadSessionFileResult = NonNullable<Awaited<ReturnType<typeof putUploadSessionFile>>>
export type AbandonUploadSessionResult = NonNullable<Awaited<ReturnType<typeof abandonUploadSession>>>
export type CommitUploadSessionResult = NonNullable<Awaited<ReturnType<typeof commitUploadSession>>>
export type DeleteUploadedSessionFileResult = NonNullable<Awaited<ReturnType<typeof deleteUploadedSessionFile>>>
export type DeleteUploadedSessionFilesResult = NonNullable<Awaited<ReturnType<typeof deleteUploadedSessionFiles>>>
export type UploadCheckApprovalRequiredResult = NonNullable<Awaited<ReturnType<typeof uploadCheckApprovalRequired>>>
export type GetMangaRelationResult = NonNullable<Awaited<ReturnType<typeof getMangaRelation>>>
export type PostMangaRelationResult = NonNullable<Awaited<ReturnType<typeof postMangaRelation>>>
export type DeleteMangaRelationIdResult = NonNullable<Awaited<ReturnType<typeof deleteMangaRelationId>>>
export type GetRatingResult = NonNullable<Awaited<ReturnType<typeof getRating>>>
export type PostRatingMangaIdResult = NonNullable<Awaited<ReturnType<typeof postRatingMangaId>>>
export type DeleteRatingMangaIdResult = NonNullable<Awaited<ReturnType<typeof deleteRatingMangaId>>>
export type GetStatisticsChapterUuidResult = NonNullable<Awaited<ReturnType<typeof getStatisticsChapterUuid>>>
export type GetStatisticsChaptersResult = NonNullable<Awaited<ReturnType<typeof getStatisticsChapters>>>
export type GetStatisticsGroupUuidResult = NonNullable<Awaited<ReturnType<typeof getStatisticsGroupUuid>>>
export type GetStatisticsGroupsResult = NonNullable<Awaited<ReturnType<typeof getStatisticsGroups>>>
export type GetStatisticsMangaUuidResult = NonNullable<Awaited<ReturnType<typeof getStatisticsMangaUuid>>>
export type GetStatisticsMangaResult = NonNullable<Awaited<ReturnType<typeof getStatisticsManga>>>
export type GetSettingsTemplateResult = NonNullable<Awaited<ReturnType<typeof getSettingsTemplate>>>
export type PostSettingsTemplateResult = NonNullable<Awaited<ReturnType<typeof postSettingsTemplate>>>
export type GetSettingsTemplateVersionResult = NonNullable<Awaited<ReturnType<typeof getSettingsTemplateVersion>>>
export type GetSettingsResult = NonNullable<Awaited<ReturnType<typeof getSettings>>>
export type PostSettingsResult = NonNullable<Awaited<ReturnType<typeof postSettings>>>
export type GetReadingHistoryResult = NonNullable<Awaited<ReturnType<typeof getReadingHistory>>>
export type ForumsThreadCreateResult = NonNullable<Awaited<ReturnType<typeof forumsThreadCreate>>>
